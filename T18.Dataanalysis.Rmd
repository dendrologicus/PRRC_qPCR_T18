---
title: "Topf18.Dataanalysis"
output:
  html_document: default
  word_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r Libraries I need, echo=FALSE, message=FALSE}
library(dplyr)
library(tidyr)
library(purrr)
library(reshape2)
library(ggplot2)
library(gridExtra) # fuer grid.arrange
library(LambertW)
library(emmeans)
library(ARTool) # For Aligned Rans transformation ANOVA of Root Rot index
library(vegan)
```


```{r WD setup, echo=FALSE, error=FALSE}

setwd("~/polybox/Dataanalysis/Topfversuch2018")    # MAC

```


```{r Color set}

Kolor = c("#009900","#FF0033","#CC9900","#663333")  # colors for the 4 soils

```


```{r Read-in ready Data, echo=FALSE, warning=FALSE}

### Die wichtigen Dataframes sind schon ready
setwd("~/polybox/Dataanalysis/Topfversuch2018/DataframeszumSchaffe")    # MAC


Topf18.COMBO.NS <- readRDS("Topf18.COMBO.NS.rds")   # Combined Pheno and qPCR Data only NS entries

Topf18.S <- readRDS("Topf18.S.rds")
Topf18.NS <- readRDS("Topf18.NS.rds")

Topf18.4.8 <- readRDS("Topf18.4.8.rds")     # only 4 soils, 8 Acc's, S and NS
Topf18.4.8.S <- readRDS("Topf18.4.8.S.rds")
Topf18.4.8.NS <- readRDS("Topf18.4.8.NS.rds")


Topf18.4.8.NS.F <- readRDS("Topf18.4.8.NS.F.rds")    # DFs fuer jeden der 4 Boeden einzeln
Topf18.4.8.NS.H <- readRDS("Topf18.4.8.NS.H.rds")
Topf18.4.8.NS.L <- readRDS("Topf18.4.8.NS.L.rds")
Topf18.4.8.NS.W <- readRDS("Topf18.4.8.NS.W.rds")
Topf18.4.8.3sick <- readRDS("Topf18.4.8.3sick.rds")

Topf18Auf.NS <- readRDS("Topf18Auf.NS.rds")      # Aufgangsdata
Topf18Auf.S <- readRDS("Topf18Auf.S.rds")
Topf18Auf.4.8.NS <- readRDS("Topf18Auf.4.8.NS.rds")
Topf18Auf.4.8.S <- readRDS("Topf18Auf.4.8.S.rds")

Topf18.FUNGI <- readRDS("Topf18.FUNGI.rds")   # DFs mit nur qPCR Conc Data
Topf18.FUNGI.F <- readRDS("Topf18.FUNGI.F.rds")
Topf18.FUNGI.H <- readRDS("Topf18.FUNGI.H.rds")
Topf18.FUNGI.L <- readRDS("Topf18.FUNGI.L.rds")
Topf18.FUNGI.W <- readRDS("Topf18.FUNGI.W.rds")
Topf18.FUNGI.3SICK <- readRDS("Topf18.FUNGI.3SICK.rds")

Topf18.COMBO.NS <- readRDS("Topf18.COMBO.NS.rds")   # Combined Pheno and qPCR (only means over ONE & TWO) Data; only NS entries

Topf18.FUNGI.MEANS <- readRDS("Topf18.FUNGI.MEANS.rds")
Topf18.FUNGI.MEANS.3SICK <- readRDS("Topf18.FUNGI.MEANS.3SICK.rds")

Topf18.FUNGI.MEANS.NONA <- readRDS("Topf18.FUNGI.MEANS.NONA.rds")
Topf18.COMBO.NS.NONA <- readRDS("Topf18.COMBO.NS.NONA.rds")

Topf18.FUNGI.S <- readRDS("Topf18.FUNGI.S.rds")
Topf18.FUNGI.S.MEANS <- readRDS("Topf18.FUNGI.S.MEANS.rds")

Topf18Auf.4.8 <- readRDS("Topf18Auf.4.8.rds")
Topf18Auf.4.8.NS <- readRDS("Topf18Auf.4.8.NS.rds")
Topf18Auf.4.8.S <- readRDS("Topf18Auf.4.8.S.rds")
```



```{r helper vectors}
thefungis <- names(Topf18.FUNGI)[c(9,12,15,18,21,24,27,30,33,36)]  # Taxa names of the fungis
thefungis <- set_names(thefungis)    #Purrr Package for set_names function
```


```{r Read-in & prep original data, echo=FALSE, eval=FALSE}

setwd("~/polybox/Dataanalysis/Topfversuch2018")    # MAC

Topf18<-read.csv(file="Topf2018_Ernte_Bonitur_2.csv", header = TRUE, sep = ",", na.strings = "NA")
Topf18$rep<-as.factor(Topf18$rep)
Topf18$table<-as.factor(Topf18$table)
Topf18$row<-as.factor(Topf18$row)
Topf18$range<-as.factor(Topf18$range)
Topf18$no.nod_5<-as.numeric(Topf18$no.nod_5)


### Auschluss von Datensätzen

Topf18[Topf18$LABEL=="4 W S64 NS",11:64] <- NA   # Exlusion of  W S64 Rep4 NS; is an outlier (e.g. RRI 6); Designvariabel & No.pl left in


###################

### data.frame only with No.pl & means per pot
Topf18<-Topf18[,c((1:10),(51:64))]

### Biomasse-Ratio for s.fw & s.dw (ratio between pot NS to S in a given Rep.)
#1.place new col
Topf18<-data.frame(append(Topf18, list(s.fw.ratioSNS=NA), after=match("ratio.s.dw.fw", names(Topf18)))) 
Topf18<-data.frame(append(Topf18, list(s.dw.ratioSNS=NA), after=match("s.fw.ratioSNS", names(Topf18))))


#2. calculate s.fwRatioSNS & s.dw...
r<-factor(levels(Topf18$rep))
s<-factor(levels(Topf18$soil))
a<-factor(levels(Topf18$acc))

for (repl in levels(r)) {
  for (sl in levels(s)){
    for (ac in levels(a)){
        
        Topf18[Topf18$rep==repl & Topf18$soil==sl & Topf18$treat=="NS" & Topf18$acc==ac,]$s.fw.ratioSNS <-
          (Topf18[Topf18$rep==repl & Topf18$soil==sl & Topf18$treat=="NS" & Topf18$acc==ac,]$s.fw.1)/
              (Topf18[Topf18$rep==repl & Topf18$soil==sl & Topf18$treat=="S" & Topf18$acc==ac,]$s.fw.1)
        
        Topf18[Topf18$rep==repl & Topf18$soil==sl & Topf18$treat=="NS" & Topf18$acc==ac,]$s.dw.ratioSNS <-
          (Topf18[Topf18$rep==repl & Topf18$soil==sl & Topf18$treat=="NS" & Topf18$acc==ac,]$s.dw.1)/
          (Topf18[Topf18$rep==repl & Topf18$soil==sl & Topf18$treat=="S" & Topf18$acc==ac,]$s.dw.1)
    }
  }
}




### data.frame subset in NS & S
Topf18.NS<-Topf18[Topf18$treat=="NS",]
Topf18.S<-Topf18[Topf18$treat=="S",]


### subset in 4 Soils with 8 Accs

Topf18.4.8 <- Topf18[Topf18$acc %in% c("C1", "C2", "G78", "G89", "S64", "S134", "S22", "S91"),]
Topf18.4.8$acc <- droplevels(Topf18.4.8$acc)

# Add Susceptible/Resistant as Factor "reslevel"
Topf18.4.8 <- data.frame(append(Topf18.4.8, list(reslevel=NA), after=match("acc", names(Topf18.4.8)))) 
Topf18.4.8$reslevel <- dplyr::recode(Topf18.4.8$acc, C1 = "R",
                                S134 = "R",
                                S91 = "R",
                                G78 = "R",
                                S64 = "R",
                                C2 = "S",
                                G89 = "S",
                                S22 = "S")

# subset more
Topf18.4.8.NS <- Topf18.4.8[Topf18.4.8$treat %in% "NS",]
Topf18.4.8.S <- Topf18.4.8[Topf18.4.8$treat %in% "S",]

#### oder 20 accs in H
Topf18.Hsoil.NS<-Topf18.NS[Topf18.NS$soil %in% c("H"),]    # nur Haeberli Boden
Topf18.Hsoil.S<-Topf18.S[Topf18.S$soil %in% c("H"),]

### subset: one Dataframe for each of the 4 soil 
Topf18.4.8.NS.F <- Topf18.4.8.NS[Topf18.4.8.NS$soil=="F",]
Topf18.4.8.NS.H <- Topf18.4.8.NS[Topf18.4.8.NS$soil=="H",]
Topf18.4.8.NS.L <- Topf18.4.8.NS[Topf18.4.8.NS$soil=="L",]
Topf18.4.8.NS.W <- Topf18.4.8.NS[Topf18.4.8.NS$soil=="W",]

Topf18.4.8.3sick <- Topf18.4.8.NS[Topf18.4.8.NS$soil!="F",]


### save those subsetted dfs!
saveRDS(Topf18.S, file = "Topf18.S.rds")
saveRDS(Topf18.NS, file = "Topf18.NS.rds")

saveRDS(Topf18.4.8, file = "Topf18.4.8.rds")
saveRDS(Topf18.4.8.S, file = "Topf18.4.8.S.rds")
saveRDS(Topf18.4.8.NS, file = "Topf18.4.8.NS.rds")

saveRDS(Topf18.Hsoil.S, file = "Topf18.Hsoil.S.rds")
saveRDS(Topf18.Hsoil.NS, file = "Topf18.Hsoil.NS.rds")

saveRDS(Topf18.4.8.NS.F, file = "Topf18.4.8.NS.F.rds")
saveRDS(Topf18.4.8.NS.H, file = "Topf18.4.8.NS.H.rds")
saveRDS(Topf18.4.8.NS.L, file = "Topf18.4.8.NS.L.rds")
saveRDS(Topf18.4.8.NS.W, file = "Topf18.4.8.NS.W.rds")
saveRDS(Topf18.4.8.3sick, file = "Topf18.4.8.3sick.rds")

```


```{r read-in original EMERGENCE data & prep, echo=FALSE, eval=FALSE}

setwd("~/polybox/Dataanalysis/Topfversuch2018")    # MAC

### Read-In Emergence
Topf18Auf <- read.csv(file="Topf2018_Aufgang_1.csv", header = TRUE, sep = ",", na.strings = "NA")
str(Topf18Auf)
Topf18Auf$rep<-as.factor(Topf18Auf$rep)

# Add Susceptible/Resistant as Factor "reslevel"
Topf18Auf <- data.frame(append(Topf18Auf, list(reslevel=NA), after=match("acc", names(Topf18Auf)))) 
Topf18Auf$reslevel <- dplyr::recode(Topf18Auf$acc, C1 = "R",
                                S134 = "R",
                                S91 = "R",
                                G78 = "R",
                                S64 = "R",
                                C2 = "S",
                                G89 = "S",
                                S22 = "S" )


### df subset S/NS ; 4-8
Topf18Auf.NS<-Topf18Auf[Topf18Auf$treat=="NS",]
Topf18Auf.S<-Topf18Auf[Topf18Auf$treat=="S",]

Topf18Auf.4.8<-Topf18Auf[Topf18Auf$acc %in% c("C1", "C2", "G78", "G89", "S64", "S134", "S22", "S91"),]
Topf18Auf.4.8$acc <- droplevels(Topf18Auf.4.8$acc)
Topf18Auf.4.8$reslevel <- droplevels(Topf18Auf.4.8$reslevel)

Topf18Auf.4.8.NS<-Topf18Auf.NS[Topf18Auf.NS$acc %in% c("C1", "C2", "G78", "G89", "S64", "S134", "S22", "S91"),]    # only  Acc's, that were tested in all 4 soils
Topf18Auf.4.8.S<-Topf18Auf.S[Topf18Auf.S$acc %in% c("C1", "C2", "G78", "G89", "S64", "S134", "S22", "S91"),]



Topf18Auf.Hsoil.NS<-Topf18Auf.NS[Topf18Auf.NS$soil %in% c("H"),]    # only Haeberli Boden
Topf18Auf.Hsoil.S<-Topf18Auf.S[Topf18Auf.S$soil %in% c("H"),]

### save those dfs!
saveRDS(Topf18Auf.NS, file = "Topf18Auf.NS.rds")
saveRDS(Topf18Auf.S, file = "Topf18Auf.S.rds")

saveRDS(Topf18Auf.4.8, file = "Topf18Auf.4.8.rds")
saveRDS(Topf18Auf.4.8.NS, file = "Topf18Auf.4.8.NS.rds")
saveRDS(Topf18Auf.4.8.S, file = "Topf18Auf.4.8.S.rds")

```


```{r read-in qPCR data, echo=FALSE, eval=FALSE}

setwd("~/polybox/Dataanalysis/Topfversuch2018/T18qPCR")    # MAC   
#setwd("C:/Users/lukas.wille/polybox/Dataanalysis/Topfversuch2018/T18qPCR") # WIN

#Read-in
Topf18.FUNGI <- read.csv(file="T18ONETWO_alle10fungi.csv", header = TRUE, sep = ",", na.strings = "NA") 

Topf18.FUNGI$rep <- as.factor(Topf18.FUNGI$rep)

### Auschluss von Datensätzen

Topf18.FUNGI[Topf18.FUNGI$LABEL=="4 W S64 NS", 6:35] <- NA   # exclusion of W S64 Rep4 NS; is a clear outlier in the phenotype


# Add Susceptible/Resistant as Factor "reslevel"
Topf18.FUNGI <- data.frame(append(Topf18.FUNGI, list(reslevel=NA), after=match("treat", names(Topf18.FUNGI)))) 

Topf18.FUNGI$reslevel <- recode(Topf18.FUNGI$acc, C1 = "R",
                                S134 = "R",
                                S91 = "R",
                                G78 = "R",
                                S64 = "R",
                                C2 = "S",
                                G89 = "S",
                                S22 = "S" )


### subset dfs
Topf18.FUNGI.S <- subset(Topf18.FUNGI, treat == "S")   # only the Sterile treatmenet

Topf18.FUNGI <- subset(Topf18.FUNGI, treat == "NS")  #leave out S entries. NOTE: I do not make a NS sufix
Topf18.FUNGI <- droplevels(Topf18.FUNGI)

Topf18.FUNGI.F <- Topf18.FUNGI[Topf18.FUNGI$soil=="F",]
Topf18.FUNGI.H <- Topf18.FUNGI[Topf18.FUNGI$soil=="H",]
Topf18.FUNGI.L <- Topf18.FUNGI[Topf18.FUNGI$soil=="L",]
Topf18.FUNGI.W <- Topf18.FUNGI[Topf18.FUNGI$soil=="W",]

Topf18.FUNGI.3SICK <- Topf18.FUNGI[Topf18.FUNGI$soil!="F",]

Topf18.FUNGI.MEANS <- Topf18.FUNGI[,c(1:6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36)]   # only the means of the two tech reps (ONE & TWO)
Topf18.FUNGI.MEANS.3SICK <- Topf18.FUNGI.MEANS[Topf18.FUNGI.MEANS$soil!="F",]

Topf18.FUNGI.S.MEANS <- Topf18.FUNGI.S[,c(1:6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36)]   # only the means of the two tech reps (ONE & TWO)


# below: replacement of qPCR means (over techrep 1 and 2) with NAs (some Analysen, for example NMDS, do not work with NAs)

Topf18.FUNGI.MEANS.NONA <- Topf18.FUNGI.MEANS

Topf18.FUNGI.MEANS.NONA[Topf18.FUNGI.MEANS.NONA$soil == "F" & Topf18.FUNGI.MEANS.NONA$acc == "C2",]$AMF <- 8  # all AMF quantities for F C2 are NA, so I cannot impute their values (as done in the loop afterwards); so I manually set it to 8 (the overall mean between S22 and G89 in F)

for (i in thefungis) {
  
  for (sl in levels(Topf18.FUNGI.MEANS.NONA$soil)) {
    for (acs in levels(Topf18.FUNGI.MEANS.NONA$acc)) {
    
       Topf18.FUNGI.MEANS.NONA[Topf18.FUNGI.MEANS.NONA$soil == sl & Topf18.FUNGI.MEANS.NONA$acc == acs,][[i]] <-
         Topf18.FUNGI.MEANS.NONA[Topf18.FUNGI.MEANS.NONA$soil == sl & Topf18.FUNGI.MEANS.NONA$acc == acs,][[i]] %>%
          replace_na(
            mean(Topf18.FUNGI.MEANS.NONA[Topf18.FUNGI.MEANS.NONA$soil == sl & Topf18.FUNGI.MEANS.NONA$acc == acs,][[i]],
                 na.rm = TRUE)
            )
      }
   }
}

## das gleiche "Implementieren"

Topf18.COMBO.NS.NONA <- Topf18.COMBO.NS

Topf18.COMBO.NS.NONA[Topf18.COMBO.NS.NONA$soil == "F" & Topf18.COMBO.NS.NONA$acc == "C2",]$AMF <- 8  # all AMF quantities for F C2 are NA, so I cannot impute their values (as done in the loop afterwards); so I manually set it to 8 (the overall mean between S22 and G89 in F)

for (i in thefungis) {
  
  for (sl in levels(Topf18.COMBO.NS.NONA$soil)) {
    for (acs in levels(Topf18.COMBO.NS.NONA$acc)) {
    
       Topf18.COMBO.NS.NONA[Topf18.COMBO.NS.NONA$soil == sl & Topf18.COMBO.NS.NONA$acc == acs,][[i]] <-
         Topf18.COMBO.NS.NONA[Topf18.COMBO.NS.NONA$soil == sl & Topf18.COMBO.NS.NONA$acc == acs,][[i]] %>%
          replace_na(
            mean(Topf18.COMBO.NS.NONA[Topf18.COMBO.NS.NONA$soil == sl & Topf18.COMBO.NS.NONA$acc == acs,][[i]],
                 na.rm = TRUE)
            )
      }
   }
}




###### abspeichern

saveRDS(Topf18.FUNGI, "Topf18.FUNGI.rds")
saveRDS(Topf18.FUNGI.F, "Topf18.FUNGI.F.rds")
saveRDS(Topf18.FUNGI.H, "Topf18.FUNGI.H.rds")
saveRDS(Topf18.FUNGI.L, "Topf18.FUNGI.L.rds")
saveRDS(Topf18.FUNGI.W, "Topf18.FUNGI.W.rds")
saveRDS(Topf18.FUNGI.3SICK, "Topf18.FUNGI.3SICK.rds")
saveRDS(Topf18.FUNGI.MEANS, "Topf18.FUNGI.MEANS.rds")
saveRDS(Topf18.FUNGI.MEANS.3SICK, "Topf18.FUNGI.MEANS.3SICK.rds")

saveRDS(Topf18.FUNGI.S, "Topf18.FUNGI.S.rds")
saveRDS(Topf18.FUNGI.S.MEANS, "Topf18.FUNGI.S.MEANS.rds")

saveRDS(Topf18.FUNGI.MEANS.NONA, "Topf18.FUNGI.MEANS.NONA.rds")

saveRDS(Topf18.COMBO.NS.NONA, "Topf18.COMBO.NS.NONA.rds")

```


```{r combine Pheno & qPCR data, echo=FALSE, eval=FALSE}

xxx <- Topf18.FUNGI.MEANS[,-c(2:6)] # throw out extra design variables
Topf18.COMBO.NS <- merge(Topf18.4.8.NS, xxx, "LABEL", all = TRUE)
Topf18.COMBO.NS <- droplevels(Topf18.COMBO.NS)

saveRDS(Topf18.COMBO.NS, file = "Topf18.COMBO.NS.rds") # Datensaetze abspeichern!

```




# __1. Phenotypic Data__

## Aufgang 7d - NS vs S
Ich muss 7d analysieren, weil Mario den Aufgang 14d nicht richtig erfasst hat...

```{r Auf7d Wcox NS vs S}
# Calculate t-tests to test NS vs S mean shoot dry weight
wilcox.test(Aufgang7d ~ treat, Topf18Auf.4.8[Topf18Auf.4.8$soil=="F",])
wilcox.test(Aufgang7d ~ treat, Topf18Auf.4.8[Topf18Auf.4.8$soil=="H",])
wilcox.test(Aufgang7d ~ treat, Topf18Auf.4.8[Topf18Auf.4.8$soil=="L",])
wilcox.test(Aufgang7d ~ treat, Topf18Auf.4.8[Topf18Auf.4.8$soil=="W",])

# also get N to indicate in the plot legend
length(Topf18Auf.4.8[Topf18Auf.4.8$soil=="W" & Topf18Auf.4.8$treat=="S", ]$Aufgang7d)
sum(is.na(Topf18Auf.4.8[Topf18Auf.4.8$soil=="W" & Topf18Auf.4.8$treat=="NS", ]$Aufgang7d))

```

F, H & W hav significantly lower Aufgang7d in NS than in S. L soil is not different! :)
N = 32 for all 4 soils. No NAs.

```{r Aufgang 7d plot NS vs S}
soil_names <- c(`F` = "Feldbach",`H` = "Kirchlindach",`L` = "Puch",`W` = "Neu-Eichenberg")

gauf <- ggplot(aes(treat, Aufgang7d), data = Topf18Auf.4.8) +
  geom_boxplot() +
  stat_summary(fun.y=mean, geom="point", shape=4, size=4) +
  facet_wrap(~soil, labeller = labeller(soil = soil_names)) +
  theme_bw() +
    theme(legend.title = element_blank(),
          panel.background =  element_blank(),
          panel.grid = element_blank(),
          axis.text.x = element_blank()) +
  labs(tag="A",
       y=expression("No. plants"),
       x=expression("")) +
  ggpubr::stat_compare_means(method = "wilcox.test", label.y = 3, label.x = 1.2)   # to directly plot p-values of t.test into plot :)

# further down I combinde this plot with the same for dry & freshweight

```


```{r summary stats Auf7d, eval=FALSE}
sumbyaccsoil_Auf7d <- Topf18Auf.4.8.NS %>% group_by(soil, acc) %>%
  summarise(N = sum(!is.na(Aufgang7d)),
            mean= mean(Aufgang7d, na.rm = TRUE),
            sd = sd(Aufgang7d, na.rm = TRUE))

write.csv(sumbyaccsoil_Auf7d, "sumbyaccsoil_Auf7d.csv")
```



## Relative shoot dry weight - NS vs S

```{r sdw t.tests NS vs S}
# Calculate t-tests to test NS vs S mean shoot dry weight
t.test(s.dw.1 ~ treat, Topf18.4.8[Topf18.4.8$soil=="F",])
t.test(s.dw.1 ~ treat, Topf18.4.8[Topf18.4.8$soil=="H",])
t.test(s.dw.1 ~ treat, Topf18.4.8[Topf18.4.8$soil=="L",])
t.test(s.dw.1 ~ treat, Topf18.4.8[Topf18.4.8$soil=="W",])

# also get N to indicate in the plot legend
length(Topf18.4.8[Topf18.4.8$soil=="F" & Topf18.4.8$treat=="S", ]$s.dw.1)
sum(is.na(Topf18.4.8[Topf18.4.8$soil=="W" & Topf18.4.8$treat=="NS", ]$s.dw.1))

```
Shoot dry weight is significantly lower in the NS tretment than in S, except for Feldbach. I indicate N = 32 for all groups, although it drops to 30 in the extremest case due to NAs...


```{r biomass NS vs S}
soil_names <- c(`F` = "Feldbach",`H` = "Kirchlindach",`L` = "Puch",`W` = "Neu-Eichenberg")

gt1 <- ggplot(aes(treat, s.fw.1), data=Topf18.4.8) +
  geom_boxplot() +
  stat_summary(fun.y=mean, geom="point", shape=4, size=4) +
  facet_wrap(~soil, labeller = labeller(soil = soil_names)) +
  theme_bw() +
    theme(legend.title = element_blank(),
          panel.background =  element_blank(),
          panel.grid = element_blank(),
          axis.text.x = element_blank()) +
  labs(tag="B",
       y=expression("Shoot fresh weight [g]"),
       x=expression("")) +
  ggpubr::stat_compare_means(method = "t.test", label.y = 4.8)   # to directly plot p-values of t.test into plot :)


gt2 <- ggplot(aes(treat, s.dw.1), data=Topf18.4.8) +
  geom_boxplot() +
  stat_summary(fun.y=mean, geom="point", shape=4, size=4) +
  facet_wrap(~soil, labeller = labeller(soil = soil_names)) +
  theme_bw() +
    theme(legend.title = element_blank(),
          panel.background =  element_blank(),
          panel.grid = element_blank()) +
  labs(tag="C",
       y=expression("Shoot dry weight [g]"),
       x=expression("Soil treatment")) +
  ggpubr::stat_compare_means(method = "t.test", label.y = 0.6)   # to directly plot p-values of t.test into plot :)


grobNSvsS <- grid.arrange(gauf, gt1, gt2, nrow = 3)


#ggsave("boxplots.sfw1sdw1.4soils.tiff", grobNSvsS, units="cm", width=15, height=25, dpi=300, compression = 'lzw')    # I save only once.

# Remove objects
rm(gt1, gt2, gauf, grobNSvsS)

```



## Relative shoot dry weight & RRI - Focus on soil
### Comparison of the four soils

```{r boxplot SDWrel. & RRI, echo=FALSE, warning=FALSE}

# first produce boxplot with individual datapoint for SDWrel.
g1 <- ggplot(Topf18.4.8.NS) +
  geom_boxplot(aes(soil, s.dw.ratioSNS), color="gray77", outlier.size = 0.1) +
  geom_jitter(aes(soil, s.dw.ratioSNS, color=soil), width = 0.1) +
  scale_color_manual(values = Kolor) +
  labs(tag="", title=expression("Relative shoot dry weight"),
       y=expression(SDW[italic(Rel.)]),
       x=expression("Soil")) +
  theme(
    axis.ticks = element_blank(),
    axis.line = element_line(size = 0.3),
    panel.background = element_blank(),
    axis.title =  element_text(size=10),
    legend.position = "none")

# then produce boxplot with individual datapoint for RRI (Topf Median!)
g2 <- ggplot(Topf18.4.8.NS) +
  geom_boxplot(aes(soil, r.aspectMEDIAN), color="gray77", outlier.size = 0.1) +
  geom_jitter(aes(soil, r.aspectMEDIAN, color=soil), width = 0.1) +
  scale_color_manual(values = Kolor) +
  labs(tag="", title=expression("Root rot index"),
       y=expression("RRI"),
       x=expression("Soil")) +
  theme(
    axis.ticks = element_blank(),
    axis.line = element_line(size = 0.3),
    panel.background = element_blank(),
    axis.title =  element_text(size=10),
    legend.position = "none")

# put the 2 plots sidebyside
gridExtra::grid.arrange(g1, g2, nrow = 1)


# Remove objects
rm(g1, g2)

```


```{r save above plots if you want, echo=FALSE, eval=FALSE}
ggsave("RRI.4B.tiff", units="cm", width=19, height=10, dpi=300, compression = 'lzw')
```

### Summarize SDWrel and RRI (mean +- SD)

```{r summary pheno for soils, over 8 accs, echo=FALSE, eval=FALSE}
# I already run this chunk once, and saved a .csv with all the necessery data. I dont do it again.
Sumlist_Pheno_4soils <- list() # initiate empty list for SDWrel and RRI

# do the summary for the two variables - I do it manuall and not with a loop
sumbysoil_phenoSDW <- Topf18.4.8.NS %>% group_by(soil) %>%
  summarise(N = sum(!is.na(s.dw.ratioSNS)),
            mean= mean(s.dw.ratioSNS, na.rm = TRUE),
            sd = sd(s.dw.ratioSNS, na.rm = TRUE))

sumbysoil_phenoRRI <- Topf18.4.8.NS %>% group_by(soil) %>%
  summarise(N = sum(!is.na(r.aspectMEDIAN)),
            mean= mean(r.aspectMEDIAN, na.rm = TRUE),
            sd = sd(r.aspectMEDIAN, na.rm = TRUE))

Sumlist_Pheno_4soils[["SDWRel"]] <- sumbysoil_phenoSDW  # I save the 2 summaries in a list...
Sumlist_Pheno_4soils[["RRI"]] <- sumbysoil_phenoRRI  #

lapply(Sumlist_Pheno_4soils, function(x) write.table(data.frame(x), 'Topf18_summary_sampling_N_mean_sd_Pheno_4soils.csv', append= T, sep=','))  #... and export it

# Remove objects
rm(sumbysoil_phenoSDW, sumbysoil_phenoRRI, Sumlist_Pheno_4soils)
```


```{r summary pheno, echo=FALSE, eval=FALSE}
# I already run this chunk once, and saved a .csv with all the necessery data. So I dont do it again.
Sumlist_Pheno_4soils8accs <- list() # initiate empty list for SDWrel and RRI

# do the summary for the two variables - I do it manuall and not with a loop
sumbyaccsoil_phenoSDW <- Topf18.4.8.NS %>% group_by(soil, acc) %>%
  summarise(N = sum(!is.na(s.dw.ratioSNS)),
            mean= mean(s.dw.ratioSNS, na.rm = TRUE),
            sd = sd(s.dw.ratioSNS, na.rm = TRUE))

sumbyaccsoil_phenoRRI <- Topf18.4.8.NS %>% group_by(soil, acc) %>%
  summarise(N = sum(!is.na(r.aspectMEDIAN)),
            mean= mean(r.aspectMEDIAN, na.rm = TRUE),
            sd = sd(r.aspectMEDIAN, na.rm = TRUE))

Sumlist_Pheno_4soils8accs[["SDWrel"]] <- sumbyaccsoil_phenoSDW  # I save the 2 summaries in a list...
Sumlist_Pheno_4soils8accs[["RRI"]] <- sumbyaccsoil_phenoRRI  # I save the 2 summaries in a list...

lapply(Sumlist_Pheno_4soils8accs, function(x) write.table(data.frame(x), 'Topf18_summary_sampling_N_mean_sd_Pheno_4soils8accs.csv', append= T, sep=','))  #... and export it

# Remove objects
rm(sumbyaccsoil_phenoSDW, sumbyaccsoil_phenoRRI)
```


### Correlations between the 4 soils
```{r correlations between the 4 soils - data prep, echo=FALSE, warning=FALSE}
### merging 4 dfs: 1 for each soil, each containing factor acc and variable to correlate (i.e. sdwratio)
# put them in a list
dfs <- list(
  dfW = data.frame(Topf18.4.8.NS.W[,c(3,27)]),
  dfL = data.frame(Topf18.4.8.NS.L[,c(3,27)]),
  dfH = data.frame(Topf18.4.8.NS.H[,c(3,27)]),
  dfF = data.frame(Topf18.4.8.NS.F[,c(3,27)])
)

#... make each sdwratio col unique!..
names(dfs$dfW)[2] <- "sdwratioW"    
names(dfs$dfL)[2] <- "sdwratioL" 
names(dfs$dfF)[2] <- "sdwratioF" 
names(dfs$dfH)[2] <- "sdwratioH" 

# ...to reduce them easily
ViermalSDW <- Reduce(function(...) merge(..., all=TRUE), dfs)

# Remove objects
rm(dfs)
```

### Pair plot with Spearman's _rho_  

```{r Pairplot orrelations between the 4 soils - plot the pair plot now, warning=FALSE, error=TRUE}
# für Pairplot brauche ich meine eigene FUnktion, die ich erst sourcen muss!

source("~/polybox/Dataanalysis/_R_CODE_FUNCTIONS/Pairplot.Funktion.R") # MAC
#source("C:/Users/lukas.wille/polybox/Dataanalysis/_R_CODE_FUNCTIONS/Pairplot.Funktion.R") # WIN

pairs(ViermalSDW[,c(2:5)],
     lower.panel = panel_scatter, upper.panel = panel_cor ,diag.panel = panel_hist,
     labels = c("W","L", "H", "F"),
     fontsize = 2,
     method = "spearman",
     main = "spearman correlation of\n SDWRel")

# Remove objects
rm(ViermalSDW)

```

```{r correlations between the 4 soils - data prep RRImedian, echo=FALSE, warning=FALSE}
### merging 4 dfs: 1 for each soil, each containing factor acc and variable to correlate (i.e. sdwratio)
# put them in a list
dfs <- list(
  dfW = data.frame(Topf18.4.8.NS.W[,c(3,17)]),
  dfL = data.frame(Topf18.4.8.NS.L[,c(3,17)]),
  dfH = data.frame(Topf18.4.8.NS.H[,c(3,17)]),
  dfF = data.frame(Topf18.4.8.NS.F[,c(3,17)])
)

#... make each RRImedian col unique!..
names(dfs$dfW)[2] <- "RRImedianW"    
names(dfs$dfL)[2] <- "RRImedianL" 
names(dfs$dfF)[2] <- "RRImedianF" 
names(dfs$dfH)[2] <- "RRImedianH" 

# ...to reduce them easily
ViermalRRI <- Reduce(function(...) merge(..., all=TRUE), dfs)

# Remove objects
rm(dfs)
```


```{r Pairplot correlations between the 4 soils for RRImedian - make the plot now, warning=FALSE}

pairs(ViermalRRI[,c(2:5)],
     lower.panel = panel_scatter, upper.panel = panel_cor ,diag.panel = panel_hist,
     labels = c("W","L", "H", "F"),
     fontsize = 2,
     method = "spearman",
     main = "Spearman correlation of\n RRI")

# Remove objects
rm(ViermalRRI)
```







# REGRESSION 1: Aufgang7d

```{r Auf7d ARTmodel rep, eval=FALSE }
art_model_Auf7d = art(Aufgang7d ~ rep, data = Topf18Auf.4.8.NS)
anova(art_model_Auf7d)
```

the factor "rep" is not significant. Then model of interest:
  
```{r Auf7d ARTmodel soil*acc}
art_model_Auf7d = art(Aufgang7d ~ soil*acc, data = Topf18Auf.4.8.NS)
art_model_Auf7d  # everything should be 0
anova(art_model_Auf7d)
```

Soil and Acc are significant, interaction not.


or the model with reslevel instead of acc:
```{r Auf7d ARTmodel soil*reslevel}
art_model_Auf7d_reslevel = art(Aufgang7d ~ soil*reslevel, data = Topf18Auf.4.8.NS)
art_model_Auf7d_reslevel  # everything should be 0
anova(art_model_Auf7d_reslevel)
```


So, some post-hoc to test differences in soil:

```{r Auf7d ARTmodel posthoc soil}

model.lm = artlm(art_model_Auf7d, "soil")   # yes, the artlm object has to be generated like this; only "soil", not the whole "soil*acc" term of the original art-analysis (see ?art)
margMeans = emmeans(model.lm, ~ soil)
pairs(margMeans,adjust = "tukey")

multcomp::cld(margMeans, alpha=0.05, Letters=letters, adjust="tukey")

```

How interesting: Puch is really the best soil for emergence....

```{r Auf7d posthoc focus Accs}

#contrast(emmeans(artlm(art_model_Auf7d, "acc"), ~ soil*acc), method="pairwise")  # every possible soil-acc pairwise comparison...

contrast(emmeans(artlm(art_model_Auf7d, "acc"), ~ acc), method="pairwise")  # this is a very dens wy of writing code: from inside out it is turning the art_model into something emmeans can read with the function _artlm_; then calculate the estimates with _emmeans_; and then calculating the contrasts.
multcomp::cld(emmeans(artlm(art_model_Auf7d, "acc"), ~ acc), alpha=0.05, Letters=letters, adjust="tukey")

```
Looking at theis analysis over all 4 soils, C2 emerges worst, G78 best.


## Analysis of emergence in the 3 sick soils

```{r Auf7d 3sick ARTmodel soil*acc}

art_model_Auf7d_3sick = art(Aufgang7d ~ soil*acc, Topf18Auf.4.8.NS[Topf18Auf.4.8.NS$soil!="F",])
art_model_Auf7d_3sick  # everything should be 0
anova(art_model_Auf7d_3sick)
```

Alright, in this analysis (over 3 sick soils), also the interaction soil x acc is significant (p=.036). That means I can not just calculate means over 3 sicks... BUT: Because F is not different than the sick soils, the analysis does not make sense... so for the publication I calcualte genotypic means over 4 soils and present that...

```{r Auf7d 3sick ARTmodel posthoc soil}
model.lm = artlm(art_model_Auf7d_3sick, "soil")
margMeans = emmeans(model.lm, ~ soil)
pairs(margMeans,adjust = "tukey")
multcomp::cld(margMeans, alpha=0.05, Letters=letters, adjust="tukey")
```

Still L has better emergence than the two other sick soil. But be cautios cause there is the interaction!

```{r Auf7d 3sick posthoc focus Accs }
# not taking care of the interaction, just emmeans over soils (wrong!)
contrast(emmeans(artlm(art_model_Auf7d, "acc"), ~ acc), method="pairwise")
multcomp::cld(emmeans(artlm(art_model_Auf7d, "acc"), ~ acc), alpha=0.05, Letters=letters, adjust="tukey")

# right way of making emmenas: put the soi*acc interaction in!
#contrast(emmeans(artlm(art_model_Auf7d, "acc"), ~ soil*acc), method="pairwise")
#multcomp::cld(emmeans(artlm(art_model_Auf7d, "acc"), ~ soil*acc), alpha=0.05, Letters=letters, adjust="tukey")
```

  

# REGRESSION 2: SDWRel

First, I have to gaussianize the SDWrel data:

```{r Gaussianize SDWRel}

# Datensatz reduzieren
Topf18.4.8.NS.SDWRel.GAUSS <- Topf18.4.8.NS[,c(1:10,27)]  # reduziere DF auf Designvariabeln und Fokus-Variabel; hier SDWRel

# Reduzierter DF zusammenbasteln (Gaussianize frisst keine NAs, drum etwas kompliziert) - fuer jede Variabel einzeln....
p <- Topf18.4.8.NS.SDWRel.GAUSS[,c(2,11)]  # nur LABEL und Fokus-Variabel
p <- p[complete.cases(p), ]   # NAs weg

G_List_SDWRel <- LambertW::Gaussianize(p[,2], type="hh", method = "MLE", return.tau.mat = TRUE) # Die "G_List..." enthaelt die transformierten Werte und die Tau-Matrix
p$SDWRel_G<-as.vector(G_List_SDWRel$input) 
Topf18.4.8.NS.SDWRel.GAUSS <- merge(Topf18.4.8.NS.SDWRel.GAUSS, p[c("LABEL", "SDWRel_G")], all.x=TRUE)

# Remove objects
rm(p)

```

Original and transformed data looks like this:

```{r SDWRel Histo comparison, echo=FALSE}
par(mfrow=c(1,2))
hist(Topf18.4.8.NS$s.dw.ratioSNS, breaks = 20)
hist(Topf18.4.8.NS.SDWRel.GAUSS$SDWRel_G, breaks = 20)
par(mfrow=c(1,1))

```


```{r Gaussianize SDWRel SAVE DATA, echo=FALSE, eval=FALSE}

# Save this DF with Gauss variable & die G_List - only the first time I run this code!
saveRDS(Topf18.4.8.NS.SDWRel.GAUSS, file = "Topf18.4.8.NS.SDWRel.GAUSS.rds")
saveRDS(G_List_SDWRel, file = "G_List_SDWRel.rds")

# Remove objects
rm(G_List_SDWRel)
```


After transformation I can do the linear Model:

```{r formulate the Model and get Anova}

LM.48.SDW_G <- lm(SDWRel_G ~ soil * acc + rep, Topf18.4.8.NS.SDWRel.GAUSS)
summary(LM.48.SDW_G)
anova(LM.48.SDW_G)

```

The factor soil is highly significant, so is acc. Their interaction is not significant, Rep also not.  The overall variance explained by the model is ok (adj. r^2^= 0.39).

Now, lets check the model assumption via the residuals:

```{r model assumptions, echo=FALSE}
par(mfrow=c(1,2))
scatter.smooth(fitted(LM.48.SDW_G), resid(LM.48.SDW_G)); abline(h=0,lty=2)
title("Tukey-Anscombe Plot")
car::qqPlot(resid(LM.48.SDW_G), pch=3, cex=0.5, id=list(n=5, cex=0.7, col="red"), line="quartiles")

```

...that looks good.


I also do the same model but with reslevel instead of acc
```{r formulate the Model and get Anova reslevel}

LM.48.SDW_G_reslevel <- lm(SDWRel_G ~ soil * reslevel + rep, Topf18.4.8.NS.SDWRel.GAUSS)
summary(LM.48.SDW_G_reslevel)
anova(LM.48.SDW_G_reslevel)

```


## POST-HOC analysis.
## FOCUS SOIL: I calculate the Estimated Means only for the 4 soils:

```{r posthoc SDW}

emm.LM.4Soils.SDW_G <- emmeans(LM.48.SDW_G, c("soil"))
POSTHOC_SDW_G_Tukey4SOils <- pairs(emm.LM.4Soils.SDW_G)   # Tukey posthoc
POSTHOC_SDW_G_Tukey4SOils
multcomp::cld(emm.LM.4Soils.SDW_G, alpha=0.05, Letters=letters, adjust="tukey")

# remove objects
rm(emm.LM.4Soils.SDW_G)
```

Result: All 3 sick soils show a significantly lower SDWRel. than in Feldbach. The L soil seems to be the sickest one and is also significantly sicker than W, but not than H.


```{r save posthoc, eval=FALSE, echo=FALSE}

# I save the posthoc analysis only the first time I run the analysis
saveRDS(POSTHOC_SDW_G_Tukey4SOils, file = "POSTHOC_SDW_G_Tukey4SOils.rds")
POSTHOC_SDW_G_Tukey4SOils

```


### Post-hoc SDWRel FOCUS GENOTYPE

As a nice start I produce an interaction plot:
```{r interaction plot}
emmip(LM.48.SDW_G, acc ~ soil)
```

The "curves" for the 8 Acc's all have more or less the same shape (around 1 in F, lowest in L). That's reflecting the no interaction between soil and acc...

For the post-hoc analysis I am interested in contrasts between Acc's. However, I calculated the contrasts within the 4 soils seperately.

```{r posthoc SDW focus genotype}

emm.LM.SoilxAcc.SDW_G <- emmeans(LM.48.SDW_G, c("soil", "acc"))
POSTHOC_SDW_G_TukeySoilxAcc <- contrast(emm.LM.SoilxAcc.SDW_G, method="pairwise", by="soil")   
multcomp::cld(emm.LM.SoilxAcc.SDW_G, alpha=0.05, Letters=letters, adjust="tukey", by="soil")

```

I notice: There is NO significant diff. between Acc's in Feldbach soil. Also in the other soils almost no sig. diff. exists. I tested (28.2.20), if this changes if I analyse one soil (H) at the time -> no it does not!


### Post-hoc SDWRel FOCUS RESLEVEL

```{r posthoc SDW focus reslevel}

emm.LM.SoilxAcc.SDW_G_reslevel <- emmeans(LM.48.SDW_G_reslevel, c("soil", "reslevel"))
POSTHOC_SDW_G_TukeySoilxAcc_reslevel <- contrast(emm.LM.SoilxAcc.SDW_G_reslevel, method="pairwise", by="soil")
POSTHOC_SDW_G_TukeySoilxAcc_reslevel
multcomp::cld(emm.LM.SoilxAcc.SDW_G_reslevel, alpha=0.05, Letters=letters, adjust="tukey", by="soil")

```
 
 
### Test only the 3 sick soils for differences in SDWRel

I want to see how the 3 sick behave when F is out. First, I subset th DF to only 3 sicks
Again, I transform the SDWRel data first.

```{r 3sick transform SDWrel}
# Datensatz reduzieren
Topf18.4.8.3sick.SDWRel.GAUSS <- Topf18.4.8.3sick[,c(1:10,27)]  # reduziere DF auf Designvariabeln und Fokus-Variabel; hier SDWRel

# Reduzierter DF zusammenbasteln (Gaussianize frisst keine NAs, drum etwas kompliziert) - fuer jede Variabel einzeln....
p <- Topf18.4.8.3sick.SDWRel.GAUSS[,c(2,11)]  # nur LABEL und Fokus-Variabel
p <- p[complete.cases(p), ]   # NAs weg

G_List_3sick_SDWRel <- LambertW::Gaussianize(p[,2], type="hh", method = "MLE", return.tau.mat = TRUE) # Die "G_List..." enthaelt die transformierten Werte und die Tau-Matrix
p$SDWRel_G<-as.vector(G_List_3sick_SDWRel$input) 
Topf18.4.8.3sick.SDWRel.GAUSS <- merge(Topf18.4.8.3sick.SDWRel.GAUSS, p[c("LABEL", "SDWRel_G")], all.x=TRUE)

```

```{r save gaussianized data, echo=FALSE, eval=FALSE}
# Save this DF with Gauss variable & die G_List - only the first time I run this code!
saveRDS(Topf18.4.8.3sick.SDWRel.GAUSS, file = "Topf18.4.8.3sick.SDWRel.GAUSS.rds")
saveRDS(G_List_3sick_SDWRel, file = "G_List_3sick_SDWRel.rds")
```

After transformation I  do the linear Model:

```{r 3 sick formulate the Model and get Anova}
LM.48.3sick.SDW_G <- lm(SDWRel_G ~ soil * acc + rep, Topf18.4.8.3sick.SDWRel.GAUSS)
summary(LM.48.3sick.SDW_G)
anova(LM.48.3sick.SDW_G)
```

The factor soil is still highly significant, so is acc. Their interaction is again not significant, also Rep not. The overall variance explained by the model is more or less equal to the model over all 4 soils (adj. r^2^= 0.43).

Now, lets check the model assumption via the residuals:

```{r 3 sick model assumptions, echo=FALSE}
par(mfrow=c(1,2))
scatter.smooth(fitted(LM.48.3sick.SDW_G), resid(LM.48.3sick.SDW_G)); abline(h=0,lty=2)
title("Tukey-Anscombe Plot")
car::qqPlot(resid(LM.48.3sick.SDW_G), pch=3, cex=0.5, id=list(n=5, cex=0.7, col="red"), line="quartiles")
```

that looks good  So I do some post-hoc analysis. Again, I calculate the Estimated Means only for the 4 soils:

```{r 3 sick posthoc SDW}
emm.LM.48.3sick.SDW_G <- emmeans(LM.48.3sick.SDW_G, c("soil"))
POSTHOC_SDW_G_Tukey3Soils <- pairs(emm.LM.48.3sick.SDW_G)   # Tukey posthoc
POSTHOC_SDW_G_Tukey3Soils
#saveRDS(POSTHOC_SDW_G_Tukey3Soils, "POSTHOC_SDW_G_Tukey3Soils.rds") # I saved the file the first time I executed the code.

# remove unused objects
rm(G_List_3sick_SDWRel)
```
Ok, the picture is almost same as for the 4 soils: H does not differentiate from L but now form W.  In L the plants show significantly lower SDWRel compared to both soils.

 
Now I also look at the factor genotype in the the 3 sick soils:

```{r 3 sick posthoc SDW focus genotype, echo=FALSE}
emm.LM.3sick_SoilxAcc.SDW_G <- emmeans(LM.48.3sick.SDW_G, c("soil", "acc"))
POSTHOC_SDW_G_Tukey_3sick_Acc <- contrast(emm.LM.3sick_SoilxAcc.SDW_G, "pairwise")   
POSTHOC_SDW_G_Tukey_3sick_Acc

multcomp::cld(emm.LM.3sick_SoilxAcc.SDW_G, alpha=0.05, Letters=letters, adjust="tukey", by="soil")

# I can also calculate the genotypic means and sig. differences over the 3 sick soils - this makes sense as I do not have interaction :)
contrast(emmeans(LM.48.3sick.SDW_G, ~ acc), method="pairwise")
multcomp::cld(emmeans(LM.48.3sick.SDW_G, ~ acc), alpha=0.05, Letters=letters, adjust="tukey")

```
Now (I guess this is mainly due to the lower level of pairwise comps. and FDR adjustments and cause the very stupid C2 in F is out) I have a little bit more signif. differences between genotypes within soil. Namely in W soil. In L again, everything is the same...

Last, but not least I do the model in 3 sick soils also for RESLEVEL:

```{r 3 sick formulate the Model and get Anova RESLEVEL}
LM.48.3sick.SDW_G_reslevel <- lm(SDWRel_G ~ soil * reslevel + rep, Topf18.4.8.3sick.SDWRel.GAUSS)
summary(LM.48.3sick.SDW_G_reslevel)
anova(LM.48.3sick.SDW_G_reslevel)
```

... and some according post-hoc:
```{r 3 sick posthoc SDW focus genotype RESLEVEL, echo=FALSE}
emm.LM.3sick_SoilxAcc.SDW_G_reslevel <- emmeans(LM.48.3sick.SDW_G_reslevel, c("soil", "reslevel"))
POSTHOC_SDW_G_Tukey_3sick_Acc_reslevel <- contrast(emm.LM.3sick_SoilxAcc.SDW_G_reslevel, "pairwise", by="soil")   
POSTHOC_SDW_G_Tukey_3sick_Acc_reslevel

multcomp::cld(emm.LM.3sick_SoilxAcc.SDW_G_reslevel, alpha=0.05, Letters=letters, adjust="tukey", by="soil")

# I can also calculate the genotypic means and sig. differences over the 3 sick soils - this makes sense as I do not have interaction :)
contrast(emmeans(LM.48.3sick.SDW_G, ~ acc), method="pairwise")
multcomp::cld(emmeans(LM.48.3sick.SDW_G, ~ acc), alpha=0.05, Letters=letters, adjust="tukey")

```



# REGRESSION 3: RRI


For this root rot index data I need to perfom a ART (aligned ranks transformation ANOVA). There is a nice description on [RCompanion](https://rcompanion.org/handbook/F_16.html)

So, for this I first need to replace all the NA's (total 6 only; 5 for C2) I have in RRIMedian. I replace the NA by the treatment (soil x acc) median:

```{r NA replace}
DFx <- Topf18.4.8.NS[,c(1:10,17)]  # Designvariabeln und RRIMedian in einen "Work-DF"

for (sl in levels(Topf18.4.8.NS$soil)) {
  
   for (acs in levels(Topf18.4.8.NS$acc)) {
    
       DFx[DFx$soil == sl & DFx$acc == acs,]$r.aspectMEDIAN <-
        DFx[DFx$soil == sl & DFx$acc == acs,]$r.aspectMEDIAN %>%
          replace_na(median(DFx[DFx$soil == sl & DFx$acc == acs,]$r.aspectMEDIAN,
                            na.rm = TRUE))
   }
}
```


```{r test rep}
art_model_1 = art(r.aspectMEDIAN ~ rep, data = DFx)
anova(art_model_1)
```

the factor "rep" is not significant. I have to test like this, because the ART wants that all the factors in the model are also tested as interaction. So the model of interest looks like this:


```{r ARTmodel of soil*acc}
art_model_RRI = art(r.aspectMEDIAN ~ soil*acc, DFx)
art_model_RRI  # everything should be 0
anova(art_model_RRI)

```

Ok. nice. Both factors soil and acc are significant; their interaction as well!

#Then, let's do some post-hoc analysis. This works with _emmeans_. Aber Achtung: die estimates sind nicht interpretierbar, da die ANalyse ja auf Rank-transformierten Daten basiert. Nur die p-values machen Sinn.

```{r ARTmodel posthoc soil}
model.lm = artlm(art_model_RRI, "soil")   # yes, the artlm object has to be generated like this; only "soil", not the whole "soil*acc" term of the original art-analysis (see ?art). THIS DOES NOT WORK FOR POST-HOC on INTERACTIONS!!
margMeans = emmeans(model.lm, ~ soil)
pairs(margMeans,adjust = "tukey")

multcomp::cld(margMeans, alpha=0.05, Letters=letters, adjust="tukey")
```

So, as for SDWRel. before F soil is less sick than the 3 sick soils. For the 3 sick soils agian, H takes an intermediate part no significant diff. from W nor L. L has significantly higher RRI than W.

#RRI Posthoc focus genotype

Note: An interaction plot is meaningless bacuse the nature of the ARtransformation makes the estimates themselfe sensless. I can just use the p-values from a posthoc...

BUT: I could plot an interactionplot with the means based on the original data.... - lets do that:

```{r interactionplot RRI means, echo=FALSE}
Topf18.4.8.NS %>% 
  ggplot() +
  aes(x = soil, color = acc, group = acc, y = r.aspectMEDIAN) +
  stat_summary(fun.y = mean, geom = "point", size = 3, alpha = 0.5, position = position_jitter(width = 0.05)) +
  stat_summary(fun.y = mean, geom = "line", aes(linetype=3)) +
  scale_linetype_identity() +
  theme_classic()


# or alternative way to plot
#dataforplot <- Topf18.4.8.NS %>% 
#  dplyr::group_by(soil, acc) %>% 
 # dplyr::summarise(sd = sd(r.aspectMEDIAN, na.rm = FALSE), mean = mean(r.aspectMEDIAN)) 

#ggplot(dataforplot, aes(x=soil, y=mean, group=acc, color=acc, position_dodge(width = 0.1))) + 
 # geom_line() +
  #geom_point(size=3, alpha=0.5) +
  #geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), width=.2,
                 #position=position_dodge(0.05)) +
 # scale_color_manual(values=c("green", "red", "green", "red", "green","red","green","green")) +
  #theme_classic()
```

Now I also see nicely where the sign. soil x acc intersction is coming from (C2 in F).

```{r RRI interaction plot, echo=FALSE, eval=FALSE}
model.lm = artlm(art_model_RRI, "soil")   # yes, the artlm object has to be generated like this; only "soil", not the whole "soil*acc" term of the original art-analysis (see ?art)

emmip(model.lm, acc ~ soil)
```

Again, I calculated the contrasts within the 4 soils seperately.

```{r RRI posthoc focus Accs}
contrast(emmeans(artlm(art_model_RRI, "acc"), ~ acc), method="pairwise")  # this is a very dens wy of writing code: from inside out it is turning the art_model into something emmeans can read with the function _artlm_; then calculate the estimates with _emmeans_; and then calculating the contrasts.
```

Last but not least: Model with RESLEVEL instead of acc
```{r ARTmodel of soil*reslevel}
art_model_RRI_reslevel = art(r.aspectMEDIAN ~ soil*reslevel, DFx)
art_model_RRI_reslevel  # everything should be 0
anova(art_model_RRI_reslevel)

```

Posthos relevel:

```{r RRI posthoc focus Reslevel}
emm.ART.3sick_SoilxAcc.RRI_reslevel <- emmeans(artlm(art_model_RRI_reslevel, "reslevel"), ~reslevel)

POSTHOC_RRI_Tukey_3sick_reslevel <- contrast(emm.ART.3sick_SoilxAcc.RRI_reslevel, "pairwise")   
POSTHOC_RRI_Tukey_3sick_reslevel

```


# RRI analysis for the 3 SICK soils only.

```{r RRI 3sick prep DFx}
# The DFx from above, where I replaced the NAs is still on, so I subset it to the 3 sick soils
DFx3sick <- DFx[DFx$soil!="F",]
```


```{r RRI 3sick ARTmodel soil*acc}
art_model_RRI_3sick = art(r.aspectMEDIAN ~ soil*acc, DFx3sick)
art_model_RRI_3sick  # everything should be 0
anova(art_model_RRI_3sick)
```

Ok. nice. Both factors soil and acc are significant. The factor soil less than with the 4 soils. BUT: The interaction is not significant anymore!

What does that mean? There is a significant soil x acc interaction when the healthy soil F is in. The interaction is not significant when the analysis is done on the 3 sick soils only. That means that a resistant genotype in a given sick soil is also resistant in another sick soil.

Then, let's do some post-hoc analysis: Again, to analyse potential differences in the 3 sick soils only I reinspect the model over the 3 sick soils. Remember, the soil x acc interaction is not significant whne only looking at the 3 sick soil.

```{r RRI 3sick ARTmodel posthoc soil}
model.lm = artlm(art_model_RRI_3sick, "soil")   # yes, the artlm object has to be generated like this; only "soil", not the whole "soil*acc" term of the original art-analysis (see ?art)
margMeans = emmeans(model.lm, ~ soil)
pairs(margMeans,adjust = "tukey")

multcomp::cld(margMeans, alpha=0.05, Letters=letters, adjust="tukey")
```

Again L has a signi. higher RRI than W. H is somehow intermediate and is not significantly different from W and L.


# RRI, 3 soils, focus genotype

```{r RRI 3sick posthoc focus Accs}
contrast(emmeans(artlm(art_model_RRI_3sick, "acc"), ~ acc), method="pairwise")

# I can also calculate the genotypic means and sig. differences over the 3 sick soils - this makes sense as I do not have interaction :)
multcomp::cld(emmeans(artlm(art_model_RRI_3sick, "acc"), ~ acc), alpha=0.05, Letters=letters, adjust="tukey")

```

Here, only 2 sig. difference: S91 vs C2 and G89.

```{r RRI 3sick ARTmodel posthoc soil Focus acc, eval=FALSE}

model.lm = artlm(art_model_RRI_3sick, "acc")   # yes, the artlm object has to be generated like this; only "soil", not the whole "soil*acc" term of the original art-analysis (see ?art)
margMeans = emmeans(model.lm, ~ acc)
pairs(margMeans,adjust = "tukey")
plot(margMeans)
multcomp::cld(margMeans, alpha=0.05, Letters=letters, adjust="tukey")

```


Over all 3 sick soils I have a significant acc effect. In contrast to the SDWRel, RRI does not differentiate really among the genotypes: Only S91 & S134 are signf. lower than C2, everyting else is indiscernable middfield.

3 sick soils RESLEVEL:

```{r RRI 3sick ARTmodel soil*reslevel}

art_model_RRI_3sick_reslevel = art(r.aspectMEDIAN ~ soil*reslevel, DFx3sick)
art_model_RRI_3sick_reslevel  # everything should be 0
anova(art_model_RRI_3sick_reslevel)

```

And posthoc 3 sick, reslevel:
```{r RRI 3sick posthoc focus Reslevel}
contrast(emmeans(artlm(art_model_RRI_3sick_reslevel, "reslevel"), ~ reslevel), method="pairwise")

# I can also calculate the genotypic means and sig. differences over the 3 sick soils - this makes sense as I do not have interaction :)
multcomp::cld(emmeans(artlm(art_model_RRI_3sick, "acc"), ~ acc), alpha=0.05, Letters=letters, adjust="tukey")

```




# __2. qPCR DATA__
### Exploration over all factor levels (soil & acc)

First, I need to explore the data a bit. To this end I produce histograms for all the quantifications over all samples.
```{r qPCR explore data nr.1, echo=FALSE}
par(mfrow=c(2,2))

for(name in names(Topf18.FUNGI[ ,(7:36)])) {
    hist(Topf18.FUNGI[,name], xlab = name, ylab = NULL, main = NULL) 
}

```

After that first inspection I produce a list with a summary of the "sampling depth", i.e. n for every treatment combination (soil _x_ acc) and mean +- SD.


```{r sampling summary, echo=FALSE, eval=FALSE}
# I already run this chunk once, and saved a .csv with all the necessery data. SO I dont do it again.
Sumlist <- list() # initiate empty list

# do the summary for every fungi over 8 accs and 4 soils - I do it manuall and not with a loop
sumbyacc <- Topf18.FUNGI %>% group_by(soil, acc) %>%
  summarise(N = sum(!is.na(Rsol)),
            nONE = sum(!is.na(RsolONE)),
            nTWO = sum(!is.na(RsolTWO)),
            mean= mean(Rsol, na.rm = TRUE),
            sd = sd(Rsol, na.rm = TRUE))

Sumlist[["Rsol"]] <- sumbyacc  # I save all the 10 summaries in a list...

lapply(Sumlist, function(x) write.table(data.frame(x), 'Topf18_qPCR_summary_N_mean_sd.csv', append= T, sep=','))  #... and export it

# now only for the 4 soils - I do it manuall and not with a loop. Again: I do it manually and copy the stuff in the file Excel File from above

Sumlist <- list() # initiate empty list

sumbyacc <- Topf18.FUNGI %>% group_by(soil) %>%
  summarise(mean= mean(Rsol, na.rm = TRUE),
            sd = sd(Rsol, na.rm = TRUE))

Sumlist[["Rsol"]] <- sumbyacc

lapply(Sumlist, function(x) write.table(data.frame(x), 'Topf18_qPCR_summary4soils_N_mean_sd.csv', append= T, sep=','))  #... and export it

# At last I also get the Grandmean
sumbyacc <- Topf18.FUNGI %>%
  summarise(N = sum(!is.na(Rsol)),
            mean= mean(Rsol),
            sd = sd(Rsol, na.rm = TRUE))

Sumlist[["Rsol"]] <- sumbyacc

lapply(Sumlist, function(x) write.table(data.frame(x), 'Topf18_qPCR_summary_N_Grandmean_sd.csv', append= T, sep=','))  #... and export it

```



Then I produce boxplots for every quantification over all samples. I do a Wilcoxon rank-sum test between tech. rep ONE and TWO for every Fungus. That is printed in the graph.

```{r qPCR explore data nr.2: boxplots over all samples, echo=FALSE}
# to do so, I trasform the data into long format, and I kick out all the design variables
xxx <- Topf18.FUNGI[,-c(2:6)]
xxx.long <- melt(xxx, id = "LABEL")

par(mfrow=c(2,2))

# Wilcoxon rank sum test for Apha between ONE and TWO
plotdata <- xxx.long %>% filter(variable=="AphaConcONE" | variable=="AphaConcTWO" | variable=="Apha")
plotdata <- droplevels(plotdata)

p <- wilcox.test(plotdata[plotdata$variable=="AphaConcONE",]$value,  plotdata[plotdata$variable=="AphaConcTWO",]$value)$p.value

boxplot(value ~ variable, plotdata, xlab=NULL, ylab="conc.")
text(x = 1.5, y = 1000, labels = round(p,2))

# Wilcoxon rank sum test for Fave between ONE and TWO
plotdata <- xxx.long %>% filter(variable=="FaveConcONE" | variable=="FaveConcTWO" | variable=="Fave")
plotdata <- droplevels(plotdata)

p <- wilcox.test(plotdata[plotdata$variable=="FaveConcONE",]$value,  plotdata[plotdata$variable=="FaveConcTWO",]$value)$p.value

boxplot(value ~ variable, plotdata, xlab=NULL, ylab="conc.")
text(x = 1.5, y = 20, labels = round(p,2))

# Wilcoxon rank sum test for Foxy between ONE and TWO
plotdata <- xxx.long %>% filter(variable=="FoxyConcONE" | variable=="FoxyConcTWO" | variable=="Foxy")
plotdata <- droplevels(plotdata)

p <- wilcox.test(plotdata[plotdata$variable=="FoxyConcONE",]$value,  plotdata[plotdata$variable=="FoxyConcTWO",]$value)$p.value

boxplot(value ~ variable, plotdata, xlab=NULL, ylab="conc.")
text(x = 1.5, y = 200, labels = round(p,2))

# Wilcoxon rank sum test for Fredo between ONE and TWO
plotdata <- xxx.long %>% filter(variable=="FredoConcONE" | variable=="FredoConcTWO" | variable=="Fredo")
plotdata <- droplevels(plotdata)

p <- wilcox.test(plotdata[plotdata$variable=="FredoConcONE",]$value,  plotdata[plotdata$variable=="FredoConcTWO",]$value)$p.value

boxplot(value ~ variable, plotdata, xlab=NULL, ylab="conc.")
text(x = 1.5, y = 15, labels = round(p,2))

# Wilcoxon rank sum test for Fsol between ONE and TWO
plotdata <- xxx.long %>% filter(variable=="FsolConcONE" | variable=="FsolConcTWO" | variable=="Fsol")
plotdata <- droplevels(plotdata)

p <- wilcox.test(plotdata[plotdata$variable=="FsolConcONE",]$value,  plotdata[plotdata$variable=="FsolConcTWO",]$value)$p.value

boxplot(value ~ variable, plotdata, xlab=NULL, ylab="conc.")
text(x = 1.5, y = 750, labels = round(p,2))

# Wilcoxon rank sum test for Phoma between ONE and TWO
plotdata <- xxx.long %>% filter(variable=="PhomaConcONE" | variable=="PhomaConcTWO" | variable=="Phoma")
plotdata <- droplevels(plotdata)

p <- wilcox.test(plotdata[plotdata$variable=="PhomaConcONE",]$value,  plotdata[plotdata$variable=="PhomaConcTWO",]$value)$p.value

boxplot(value ~ variable, plotdata, xlab=NULL, ylab="conc.")
text(x = 1.5, y = 75, labels = round(p,2))

# Wilcoxon rank sum test for Pult between ONE and TWO
plotdata <- xxx.long %>% filter(variable=="PultConcONE" | variable=="PultConcTWO" | variable=="Pult")
plotdata <- droplevels(plotdata)

p <- wilcox.test(plotdata[plotdata$variable=="PultConcONE",]$value,  plotdata[plotdata$variable=="PultConcTWO",]$value)$p.value

boxplot(value ~ variable, plotdata, xlab=NULL, ylab="conc.")
text(x = 1.5, y = 100, labels = round(p,2))

# Wilcoxon rank sum test for Rsol between ONE and TWO
plotdata <- xxx.long %>% filter(variable=="RsolONE" | variable=="RsolTWO" | variable=="Rsol")
plotdata <- droplevels(plotdata)

p <- wilcox.test(plotdata[plotdata$variable=="RsolONE",]$value,  plotdata[plotdata$variable=="RsolTWO",]$value)$p.value

boxplot(value ~ variable, plotdata, xlab=NULL, ylab="conc.")
text(x = 1.5, y = 100, labels = round(p,2))

# Wilcoxon rank sum test for AMF between ONE and TWO
plotdata <- xxx.long %>% filter(variable=="AMFONE" | variable=="AMFTWO" | variable=="AMF")
plotdata <- droplevels(plotdata)

p <- wilcox.test(plotdata[plotdata$variable=="AMFONE",]$value,  plotdata[plotdata$variable=="AMFTWO",]$value)$p.value

boxplot(value ~ variable, plotdata, xlab=NULL, ylab="conc.")
text(x = 1.5, y = 50000, labels = round(p,2))

# Wilcoxon rank sum test for Cros between ONE and TWO
plotdata <- xxx.long %>% filter(variable=="CrosONE" | variable=="CrosTWO" | variable=="Cros")
plotdata <- droplevels(plotdata)

p <- wilcox.test(plotdata[plotdata$variable=="CrosONE",]$value,  plotdata[plotdata$variable=="CrosTWO",]$value)$p.value

boxplot(value ~ variable, plotdata, xlab=NULL, ylab="conc.")
text(x = 1.5, y = 50, labels = round(p,2))

```

For the first example, Aphano, I see that there is a sign. difference (Wilcox, _p_ = 0.02) between tech rep ONE and tech rep TWO.


### Exploration of qPCr quant. (the mean of the two tech Reps) over all genotypes, for the 4 soils seperately

## qPCR in the STERILE - roots; that is only C1 & C2
I do only the stats on the means beetween ONE & TWO
#Overview of fungal quants in the 4 soils

```{r fungi stack STERILE, echo=FALSE}
###### Stacked fungis
# Calc mean over soil&acc for each fungi
sum.fungi.S <- Topf18.FUNGI.S %>% group_by(soil, acc) %>%
  summarise(Apha= mean(Apha, na.rm = TRUE),
            Fave= mean(Fave, na.rm = TRUE),
            Foxy= mean(Foxy, na.rm = TRUE),
            Fredo= mean(Fredo, na.rm = TRUE),
            Fsol= mean(Fsol, na.rm = TRUE),
            Phoma= mean(Phoma, na.rm = TRUE),
            Pult= mean(Pult, na.rm = TRUE),
            Rsol= mean(Rsol, na.rm = TRUE),
            AMF= mean(sqrt(AMF), na.rm = TRUE),   # watch out sqrt of AMF quant!!!
            Cros= mean(Cros, na.rm = TRUE))


# reformat for ggplot
sum.fungi.S.long <- melt(sum.fungi.S, id = c("soil", "acc"))

# plot Stacks in S, with the same y-axis as the NS treatment for comparison, but with detail panel inlets...
myKolor = c("#A1D99B", "#800026", "darkgreen", "#FC9272", "#DE2D26", "#C994C7", "#E6550D", "black", "#FED976", "pink")

# First: big plot with 4 soil panels
stacksSbig <- ggplot(sum.fungi.S.long, aes(x = acc, fill=variable)) + 
    geom_bar(data = subset(sum.fungi.S.long, variable %in% c("Fsol", "Apha", "Fave", "Foxy", "Fredo", "Pult", "Rsol", "Phoma")), aes(y = value), stat = "identity") +
    geom_bar(data = subset(sum.fungi.S.long, variable %in% c("AMF", "Cros")), aes(y = -value), stat = "identity") +
    scale_fill_manual(values = myKolor) +
    scale_y_continuous(limits = c(0,2000)) +
    geom_hline(yintercept = 0) +
    facet_wrap(~soil, labeller = labeller(soil=soil_names)) +
    theme_classic() +
    theme(legend.title = element_blank(),
          panel.border = element_rect(colour = "black", fill=NA, size=0.5),
          legend.text = element_text(size=10),
          legend.key.size = unit(1,"line"),
          axis.title = element_text(size=10),
          axis.text = element_text(size=8),
          strip.background = element_blank()) +
    annotate("text", x=3, y=200, label='NA', size=2) +
  annotate("text", x=4, y=200, label='NA', size=2) +
  annotate("text", x=5, y=200, label='NA', size=2) +
  annotate("text", x=6, y=200, label='NA', size=2) +
  annotate("text", x=7, y=200, label='NA', size=2) +
  annotate("text", x=8, y=200, label='NA', size=2) +
    labs(y = expression(paste("pg ", rct^-1)), x="Genotype")


# The, F inlet
inletF <- ggplot(sum.fungi.S.long, aes(x = acc, fill=variable)) + 
    geom_bar(data = subset(sum.fungi.S.long, variable %in% c("Fsol", "Apha", "Fave", "Foxy", "Fredo", "Pult", "Rsol", "Phoma") & acc %in% c("C1", "C2") & soil %in% "F"), aes(y = value), stat = "identity") +
    geom_bar(data = subset(sum.fungi.S.long, variable %in% c("AMF", "Cros") & acc %in% c("C1", "C2")& soil %in% "F"), aes(y = -value), stat = "identity") +
    scale_fill_manual(values = myKolor) +
    geom_hline(yintercept = 0) +
    theme_classic() +
    theme(legend.position = "none", panel.border = element_rect(colour = "black", fill=NA, size=0.5),
          axis.title = element_blank(), axis.text = element_text(size=6),strip.background = element_blank())

# The, H inlet
inletH <- ggplot(sum.fungi.S.long, aes(x = acc, fill=variable)) + 
    geom_bar(data = subset(sum.fungi.S.long, variable %in% c("Fsol", "Apha", "Fave", "Foxy", "Fredo", "Pult", "Rsol", "Phoma") & acc %in% c("C1", "C2") & soil %in% "H"), aes(y = value), stat = "identity") +
    geom_bar(data = subset(sum.fungi.S.long, variable %in% c("AMF", "Cros") & acc %in% c("C1", "C2")& soil %in% "H"), aes(y = -value), stat = "identity") +
    scale_fill_manual(values = myKolor) +
    geom_hline(yintercept = 0) +
    theme_classic() +
    theme(legend.position = "none", panel.border = element_rect(colour = "black", fill=NA, size=0.5),
          axis.title = element_blank(), axis.text = element_text(size=6),strip.background = element_blank())

# The, L inlet
inletL <- ggplot(sum.fungi.S.long, aes(x = acc, fill=variable)) + 
    geom_bar(data = subset(sum.fungi.S.long, variable %in% c("Fsol", "Apha", "Fave", "Foxy", "Fredo", "Pult", "Rsol", "Phoma") & acc %in% c("C1", "C2") & soil %in% "L"), aes(y = value), stat = "identity") +
    geom_bar(data = subset(sum.fungi.S.long, variable %in% c("AMF", "Cros") & acc %in% c("C1", "C2")& soil %in% "L"), aes(y = -value), stat = "identity") +
    scale_fill_manual(values = myKolor) +
    geom_hline(yintercept = 0) +
    theme_classic() +
    theme(legend.position = "none", panel.border = element_rect(colour = "black", fill=NA, size=0.5),
          axis.title = element_blank() ,axis.text = element_text(size=6), strip.background = element_blank())

# The, W inlet
inletW <- ggplot(sum.fungi.S.long, aes(x = acc, fill=variable)) + 
    geom_bar(data = subset(sum.fungi.S.long, variable %in% c("Fsol", "Apha", "Fave", "Foxy", "Fredo", "Pult", "Rsol", "Phoma") & acc %in% c("C1", "C2") & soil %in% "W"), aes(y = value), stat = "identity") +
    geom_bar(data = subset(sum.fungi.S.long, variable %in% c("AMF", "Cros") & acc %in% c("C1", "C2")& soil %in% "W"), aes(y = -value), stat = "identity") +
    scale_fill_manual(values = myKolor) +
    geom_hline(yintercept = 0) +
    theme_classic() +
    theme(legend.position = "none", panel.border = element_rect(colour = "black", fill=NA, size=0.5),
          axis.title = element_blank(), axis.text = element_text(size=6), strip.background = element_blank())


# Plot the final plot with inlets
# for that you need the function "annotation_custom2_FUN" :)
source("~/polybox/Dataanalysis/_R_CODE_FUNCTIONS/annotation_custom2_FUN.R") # MAC
#source("C:/Users/lukas.wille/polybox/Dataanalysis/_R_CODE_FUNCTIONS/Pairplot.Funktion.R") # WIN

stacksSbig +
    annotation_custom2(grob=ggplotGrob(inletF), data = subset(sum.fungi.S.long, soil %in% "F"),
                      ymin = 700, ymax=2000, xmin=3, xmax=6) +
    annotation_custom2(grob=ggplotGrob(inletH), data = subset(sum.fungi.S.long, soil %in% "H"),
                      ymin = 700, ymax=2000, xmin=3, xmax=6) +
    annotation_custom2(grob=ggplotGrob(inletL), data = subset(sum.fungi.S.long, soil %in% "L"),
                      ymin = 700, ymax=2000, xmin=3, xmax=6) +
    annotation_custom2(grob=ggplotGrob(inletW), data = subset(sum.fungi.S.long, soil %in% "W"),
                      ymin = 700, ymax=2000, xmin=3, xmax=6)

#ggsave("Fungisstack4soilsSTERILE.tiff", units="cm", width=18, height=12, dpi=300, compression = 'lzw')

rm(stacksSbig, inletF, inletH, inletL, inletW, sum.fungi.S, sum.fungi.S.long)

```

From this first graph I see that in Feldbach C1 & C2 have a little bit of Apha, Fave (most) & Foxy contamination. In Kirchlindach, C1 has considerable Pult (and a little bit Foxy/Apha), C2 Foxy (Fave/Apha) contamination. In Puch & Witz C1 is clean, but C2 is heavily contaminated. "Heavy" means ~50pg/rct (thats 10-20 times less than in the NS treatment).

I manualy summarize the raw data of S qPCR quant:

```{r manual sum of S qPCR, echo=FALSE, eval=FALSE}

subset(Topf18.FUNGI.S.MEANS, acc %in% "C2" & soil %in% "W")

summary(na.omit(sum.fungi.S.long[sum.fungi.S.long$value>0,]$value))

```
__________________________
F - C1
Apha: 0.6, 5.1, 0, 0.1
Fave: 0, 11.5, 0, 0
Foxy: 0.7, 0.2, 3.7, 0.7
Phoma: 0, 0, 0, 0.1
Pult: 0.5, 0, 0, 0.0
Rsol: 0, 0, 0, 0.5

F - C2
Fave: 3, 13, 0, 1
Foxy: 0.2, 0.2, 0.2, 5.6
Fsol: 0, 0.3, 0.5, 0
Pult: 0.5, 0, 0, 0.0

H - C1
Apha: 1.8, 0.5, 0, 0.2
Foxy: 0.3, 0.1, 0.1, 4.35
Fsol: 0.5, 0, 0, 0
Pult: 82.575, 0, 0, 0.0

H - C2
Apha: 0.7, 0, 2.5, 0
Fave: 0, 0, 0, 0.5
Foxy: 1.9, 0.3, 1.2, 43.2
Phoma: 0, 0, 0.8, 0


L - C1
Apha: 0, 1.2, 0, 0.2
Foxy: 0, 0.2, 0.2, 0.2
Fsol: 1.5, 0, 0, 0

L - C2
Apha: 284.5, 0, 0, 0.2
Fave: 2, 0, 0, 0
Foxy: 21.8, 0.3, 0.3, 2.6
Fredo: 0.5, 0, 0, 0
Fsol: 197, 0.3, 0.5, 0.5
Phoma: 1.5, 0, 0, 0
Pult: 0.5, 0, 0, 11.47
Rsol: 2, 0, 0, 0
AMF: 0, 0, 0, 38918.6

W - C1
Apha: 0, 0, 0, 1
Foxy: 0.1, 0, 0.1, 0.8
AMF: 0, 0, 0, 6.7

W - C2
Apha: 0, 0, 0, 0.3
Fave: 4.5, 0, 0, 0
Foxy: 0, 0, 0.2, 21.2
Fsol:  0, 0, 0, 445.5
Phoma: 0, 0, 0, 0.5
AMF: 0, 0, 0, 24.7
______________________________
For most of these "contaminations" the levels are really low (< 1 pg). When I have large values, these large values are extremes, i.e. appear in one sample and are not reproduced in others.
78 out of 320 tests are positive; 31 with > 1 pg/rct; 12 with > 10pg/rct; 4 > 100 pg/rct.


## qPCR in the NONSTERIL - roots

```{r data prep soil plots}
xxx <- Topf18.FUNGI[,-c(2:4)]
xxx.long <- melt(xxx, id = c("LABEL","soil", "acc"))

```

```{r boxplot for 4 soils, warning=FALSE}

### Boxplot 4 Boeden fuer alle 10 Fungi - Mmit schoenem "map"-LOOP durch die Funktion (tidyverse Package!)

boxplot_fun <- function(x)  {   # NA, zeros and non-zeros counter & Plot function, die x annehmen kann; x sind die 10 Namen der Fungi in response
  
  subdat <- xxx.long %>% filter(variable == x)

    gg<- ggplot(subdat, aes(variable, value)) +
    geom_boxplot() +
    facet_wrap(~soil) +
    theme(axis.title.x = element_blank())
  
}

TenFungiPlot <- map(thefungis, ~ boxplot_fun(.x)) # "map"-Loop aus dem purrr Package, die es erlaubt über alle Levels des Vektors "thefungis" die Funktion "boxplot_fun" zu bedienen.

cowplot::plot_grid(plotlist = TenFungiPlot, ncol = 4)

#remove objects
rm(TenFungiPlot)

```

Wo habe ich NAs oder Nuller?
```{r Wo habe ich NAs und Nuller Concs.?}
vec <- vector() #leeren Vektor initialisieren um ihn dann im for loop zu füllen...

for (resp in names(thefungis)) {   # response ist im oberen chuck definiert (Namen der Pilze)
  subdat <- xxx.long %>% filter(variable == resp)
  NAs <- sum(is.na(subdat$value))
  zeros <- sum(subdat$value==0, na.rm = TRUE)
  nonzeros <- sum(subdat$value>0, na.rm = TRUE)
  
  vec <- c(vec, NAs, zeros, nonzeros)
  
}

mat <- matrix(vec, nrow=3)
mat <- as.data.frame(mat, row.names = c("NAs", "zeros", "values")) #... und daraus eine Tabelle zu machen
colnames(mat) <- thefungis
print("NAs & zero-quantifications - Overall")
mat
```


### Exploration of quantification data for the 4 soils seperately
Wo habe ich NAs oder Nuller?
Feldbach:
```{r Wo habe ich NAs und Nuller Concs.? in F, echo=FALSE}
vecF <- vector()       #vector vorbereiten um ihn dann im for loop zu füllen...

for (fungs in names(thefungis)) {   # response ist im oberen chuck definiert (Namen der Pilze)
    
    
      subdat <- xxx.long %>% filter(soil == "F", variable == fungs)
      NAs <- sum(is.na(subdat$value))
      zeros <- sum(subdat$value==0, na.rm = TRUE)
      nonzeros <- sum(subdat$value>0, na.rm = TRUE)
  
      vecF <- c(vecF, NAs, zeros, nonzeros)
    
}

matF <- matrix(vecF, nrow=3)
matF <- as.data.frame(matF, row.names = c("NAs", "zeros", "values")) #... und daraus eine Tabelle zu machen
colnames(matF) <- thefungis
print("NAs & zero-quantifications - Feldbach")
mat
```

Kirchlindach:
```{r Wo habe ich NAs und Nuller Concs.? in H, echo=FALSE}
vecH <- vector()       #vector vorbereiten um ihn dann im for loop zu füllen...

for (fungs in names(thefungis)) {   # response ist im oberen chuck definiert (Namen der Pilze)
    
    
      subdat <- xxx.long %>% filter(soil == "H", variable == fungs)
      NAs <- sum(is.na(subdat$value))
      zeros <- sum(subdat$value==0, na.rm = TRUE)
      nonzeros <- sum(subdat$value>0, na.rm = TRUE)
  
      vecH <- c(vecH, NAs, zeros, nonzeros)
    
}

matH <- matrix(vecH, nrow=3)
matH <- as.data.frame(matH, row.names = c("NAs", "zeros", "values")) #... und daraus eine Tabelle zu machen
colnames(matH) <- thefungis
print("NAs & zero-quantifications - Kirchlindach")
matH
```

Lfl:
```{r Wo habe ich NAs und Nuller Concs.? in L, echo=FALSE}
vecL <- vector()       #vector vorbereiten um ihn dann im for loop zu füllen...

for (fungs in names(thefungis)) {   # response ist im oberen chuck definiert (Namen der Pilze)
    
    
      subdat <- xxx.long %>% filter(soil == "L", variable == fungs)
      NAs <- sum(is.na(subdat$value))
      zeros <- sum(subdat$value==0, na.rm = TRUE)
      nonzeros <- sum(subdat$value>0, na.rm = TRUE)
  
      vecL <- c(vecL, NAs, zeros, nonzeros)
    
}

matL <- matrix(vecL, nrow=3)
matL <- as.data.frame(matL, row.names = c("NAs", "zeros", "values")) #... und daraus eine Tabelle zu machen
colnames(matL) <- thefungis
print("NAs & zero-quantifications - Lfl")
matL
```

Witzenhausen:
```{r Wo habe ich NAs und Nuller Concs.? in W, echo=FALSE}
vecW <- vector()       #vector vorbereiten um ihn dann im for loop zu füllen...

for (fungs in names(thefungis)) {   # response ist im oberen chuck definiert (Namen der Pilze)
    
    
      subdat <- xxx.long %>% filter(soil == "W", variable == fungs)
      NAs <- sum(is.na(subdat$value))
      zeros <- sum(subdat$value==0, na.rm = TRUE)
      nonzeros <- sum(subdat$value>0, na.rm = TRUE)
  
      vecW <- c(vecW, NAs, zeros, nonzeros)
    
}

matW <- matrix(vecW, nrow=3)
matW <- as.data.frame(matW, row.names = c("NAs", "zeros", "values")) #... und daraus eine Tabelle zu machen
colnames(matW) <- thefungis
print("NAs & zero-quantifications - Witzh")
matW
```
<br>
###Overview of fungal quants in the 4 soils

```{r fungi stack, echo=FALSE}
###### Stacked fungis
# Calc mean over soil&acc for each fungi
sum.fungi <- Topf18.FUNGI %>% group_by(soil, acc) %>%
  summarise(Apha= mean(Apha, na.rm = TRUE),
            Fave= mean(Fave, na.rm = TRUE),
            Foxy= mean(Foxy, na.rm = TRUE),
            Fredo= mean(Fredo, na.rm = TRUE),
            Fsol= mean(Fsol, na.rm = TRUE),
            Phoma= mean(Phoma, na.rm = TRUE),
            Pult= mean(Pult, na.rm = TRUE),
            Rsol= mean(Rsol, na.rm = TRUE),
            AMF= mean(sqrt(AMF), na.rm = TRUE),   # watch out sqrt of AMF quant!!!
            Cros= mean(Cros, na.rm = TRUE))


# reformat for ggplot
sum.fungi.long <- melt(sum.fungi, id = c("soil", "acc"))

# plot
myKolor = c("#A1D99B", "#800026", "darkgreen", "#FC9272", "#DE2D26", "#C994C7", "#E6550D", "black", "#FED976", "pink")

ggplot(sum.fungi.long, aes(x = acc, fill=variable)) + 
    geom_bar(data = subset(sum.fungi.long, variable %in% c("Fsol", "Apha", "Fave", "Foxy", "Fredo", "Pult", "Rsol", "Phoma")), aes(y = value), stat = "identity") +
    geom_bar(data = subset(sum.fungi.long, variable %in% c("AMF", "Cros")), aes(y = -value), stat = "identity") +
    scale_fill_manual(values = myKolor) +  
    geom_hline(yintercept = 0) +
    facet_wrap(~soil) +
    theme_classic() +
    theme(legend.title = element_blank(), panel.border = element_rect(colour = "black", fill=NA, size=0.5)) +
    theme(strip.background = element_blank())
```


### Correlations of fungal conc. overall

```{r Corr conc overall with heatmap, echo=FALSE}

rhos_mat <- round(Hmisc::rcorr(as.matrix(Topf18.FUNGI[,c(9,12,15,18,21,24,27,30,33,36)]), type="spearman")$r,2)
rhos_mat[lower.tri(rhos_mat)] <- NA # Get only upper triangle of the correlation matrix
melted_rhos_mat <- melt(rhos_mat, na.rm = TRUE)

pvals_mat <- round(Hmisc::rcorr(as.matrix(Topf18.FUNGI[,c(9,12,15,18,21,24,27,30,33,36)]), type="spearman")$P,5)
pvals_mat[lower.tri(pvals_mat)] <- NA # again only upper triangle of the correlation matrix
diag(pvals_mat) <- 0   # set the diagonal to 0.00 instead of "NA" - for the plotting, so the diagonal do get 3 stars for significance
melted_pvals_mat <- melt(pvals_mat, na.rm = TRUE)
melted_pvals_mat$stars <- cut(melted_pvals_mat$value, breaks=c(-Inf, 0.001, 0.01, 0.05, Inf), label=c("***", "**", "*", "ns"))  # Create column of significance labels


ggplot(data = melted_rhos_mat, aes(Var2, Var1, fill = value)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                       midpoint = 0, limit = c(-1,1), space = "Lab", 
                       name="Spearman's \nRho") +
  geom_text(aes(label = melted_pvals_mat$stars), vjust = 1) +
  theme_minimal() + 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, 
                                   size = 9, hjust = 1)) +
  coord_fixed()


```

### Then correlations within the 4 soils seperately
Feldbach:
```{r Corr conc Feldbach with heatmap, echo=FALSE}

rhos_mat <- round(Hmisc::rcorr(as.matrix(Topf18.FUNGI[Topf18.FUNGI$soil=="F",c(9,12,15,18,21,24,27,30,33,36)]), type="spearman")$r,2)
rhos_mat[lower.tri(rhos_mat)] <- NA # Get only upper triangle of the correlation matrix
melted_rhos_mat <- melt(rhos_mat, na.rm = TRUE)

pvals_mat <- round(Hmisc::rcorr(as.matrix(Topf18.FUNGI[Topf18.FUNGI$soil=="F",c(9,12,15,18,21,24,27,30,33,36)]), type="spearman")$P,5)
pvals_mat[lower.tri(pvals_mat)] <- NA # again only upper triangle of the correlation matrix
diag(pvals_mat) <- 0  # set the diagonal to 0.00 instead of "NA" - for the plotting, so the diagonal do get 3 stars for significance
melted_pvals_mat <- melt(pvals_mat, na.rm = TRUE)
melted_pvals_mat$stars <- cut(melted_pvals_mat$value, breaks=c(-Inf, 0.001, 0.01, 0.05, Inf), label=c("***", "**", "*", ""))  # Create column of significance labels


ggplot(data = melted_rhos_mat, aes(Var2, Var1, fill = value)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                       midpoint = 0, limit = c(-1,1), space = "Lab", 
                       name="Spearman's \nRho") +
  geom_text(aes(label = melted_pvals_mat$stars), vjust = 1) +
  theme_minimal() + 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, 
                                   size = 9, hjust = 1), plot.title = element_text("Feldbach")) +
  coord_fixed()

```

Kirchlindach:
```{r Corr conc Kirchlindach with heatmap, echo=FALSE}

rhos_mat <- round(Hmisc::rcorr(as.matrix(Topf18.FUNGI[Topf18.FUNGI$soil=="H",c(9,12,15,18,21,24,27,30,33,36)]), type="spearman")$r,2)
rhos_mat[lower.tri(rhos_mat)] <- NA # Get only upper triangle of the correlation matrix
melted_rhos_mat <- melt(rhos_mat, na.rm = TRUE)

pvals_mat <- round(Hmisc::rcorr(as.matrix(Topf18.FUNGI[Topf18.FUNGI$soil=="H",c(9,12,15,18,21,24,27,30,33,36)]), type="spearman")$P,5)
pvals_mat[lower.tri(pvals_mat)] <- NA # again only upper triangle of the correlation matrix
diag(pvals_mat) <- 0  # set the diagonal to 0.00 instead of "NA" - for the plotting, so the diagonal do get 3 stars for significance
melted_pvals_mat <- melt(pvals_mat, na.rm = TRUE)
melted_pvals_mat$stars <- cut(melted_pvals_mat$value, breaks=c(-Inf, 0.001, 0.01, 0.05, Inf), label=c("***", "**", "*", ""))  # Create column of significance labels


ggplot(data = melted_rhos_mat, aes(Var2, Var1, fill = value)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                       midpoint = 0, limit = c(-1,1), space = "Lab", 
                       name="Spearman's \nRho") +
  geom_text(aes(label = melted_pvals_mat$stars), vjust = 1) +
  theme_minimal() + 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, 
                                   size = 9, hjust = 1), plot.title = element_text("Kirchlindach")) +
  coord_fixed()

```

Lfl:
```{r Corr conc Lfl with heatmap, echo=FALSE}

rhos_mat <- round(Hmisc::rcorr(as.matrix(Topf18.FUNGI[Topf18.FUNGI$soil=="L",c(9,12,15,18,21,24,27,30,33,36)]), type="spearman")$r,2)
rhos_mat[lower.tri(rhos_mat)] <- NA # Get only upper triangle of the correlation matrix
melted_rhos_mat <- melt(rhos_mat, na.rm = TRUE)

pvals_mat <- round(Hmisc::rcorr(as.matrix(Topf18.FUNGI[Topf18.FUNGI$soil=="L",c(9,12,15,18,21,24,27,30,33,36)]), type="spearman")$P,5)
pvals_mat[lower.tri(pvals_mat)] <- NA # again only upper triangle of the correlation matrix
diag(pvals_mat) <- 0  # set the diagonal to 0.00 instead of "NA" - for the plotting, so the diagonal do get 3 stars for significance
melted_pvals_mat <- melt(pvals_mat, na.rm = TRUE)
melted_pvals_mat$stars <- cut(melted_pvals_mat$value, breaks=c(-Inf, 0.001, 0.01, 0.05, Inf), label=c("***", "**", "*", ""))  # Create column of significance labels


ggplot(data = melted_rhos_mat, aes(Var2, Var1, fill = value)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                       midpoint = 0, limit = c(-1,1), space = "Lab", 
                       name="Spearman's \nRho") +
  geom_text(aes(label = melted_pvals_mat$stars), vjust = 1) +
  theme_minimal() + 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, 
                                   size = 9, hjust = 1), plot.title = element_text("Lfl")) +
  coord_fixed()

```

Witzenhausen:
```{r Corr conc Witzenhausen with heatmap, echo=FALSE}

rhos_mat <- round(Hmisc::rcorr(as.matrix(Topf18.FUNGI[Topf18.FUNGI$soil=="W",c(9,12,15,18,21,24,27,30,33,36)]), type="spearman")$r,2)
rhos_mat[lower.tri(rhos_mat)] <- NA # Get only upper triangle of the correlation matrix
melted_rhos_mat <- melt(rhos_mat, na.rm = TRUE)

pvals_mat <- round(Hmisc::rcorr(as.matrix(Topf18.FUNGI[Topf18.FUNGI$soil=="W",c(9,12,15,18,21,24,27,30,33,36)]), type="spearman")$P,5)
pvals_mat[lower.tri(pvals_mat)] <- NA # again only upper triangle of the correlation matrix
diag(pvals_mat) <- 0  # set the diagonal to 0.00 instead of "NA" - for the plotting, so the diagonal do get 3 stars for significance
melted_pvals_mat <- melt(pvals_mat, na.rm = TRUE)
melted_pvals_mat$stars <- cut(melted_pvals_mat$value, breaks=c(-Inf, 0.001, 0.01, 0.05, Inf), label=c("***", "**", "*", ""))  # Create column of significance labels


ggplot(data = melted_rhos_mat, aes(Var2, Var1, fill = value)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                       midpoint = 0, limit = c(-1,1), space = "Lab", 
                       name="Spearman's \nRho") +
  geom_text(aes(label = melted_pvals_mat$stars), vjust = 1) +
  theme_minimal() + 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, 
                                   size = 9, hjust = 1), plot.title = element_text("Witzenhausen")) +
  coord_fixed()

```

### Now, lets analyse the qPCR Data and do some Anovas
### First, on untransformed data
```{r qPCR anovas 4 soils, echo=FALSE}
qPCRlist <- list() #initiate an empty list

for (i in thefungis) {
  md <- lm(Topf18.FUNGI[[i]] ~ soil*acc + rep, data = Topf18.FUNGI) # here the Model is formulated
  qPCRlist[[paste("call",i)]] <- summary(md)$call             # then the call extracted
  qPCRlist[[paste("R2",i)]] <- summary(md)$adj.r.squared      # then adj. R.suqared extracted
  qPCRlist[[paste("Anova",i)]] <- anova(md)                   # ANOVA table calulated
  
  print(i)  #this is kind of Title (which Fungus)
  print(summary(md)$call)
  print(summary(md)$adj.r.squared)
  print(anova(md))
  
  par(mfrow=c(1,2))    # some residual diagnostics
  scatter.smooth(fitted(md), resid(md)); abline(h=0,lty=2)
  title(i)
  car::qqPlot(resid(md), pch=3, cex=0.5, id=list(n=5, cex=0.7, col="red"), line="quartiles")

}

```

We can clearly see that the distribution of the residual is not good. So lets transform  the data:

### log10(x + 0.1) transformed data

```{r qPCR anovas 4 soils LOGtransform, echo=FALSE}
qPCRlist2 <- list() #initiate an empty list

for (i in thefungis) {
  md <- lm(log10(Topf18.FUNGI[[i]]+0.1) ~ soil*acc + rep, data = Topf18.FUNGI) # here the Model is formulated
  qPCRlist2[[paste("call",i)]] <- summary(md)$call             # then the call extracted
  qPCRlist2[[paste("R2",i)]] <- summary(md)$adj.r.squared      # then adj. R.suqared extracted
  qPCRlist2[[paste("Anova",i)]] <- anova(md)                   # ANOVA table calulated
  
  print(i)  #this is kind of Title (which Fungus)
  print(summary(md)$call)
  print(summary(md)$adj.r.squared)
  print(anova(md))
  
  par(mfrow=c(1,2))    # some residual diagnostics
  scatter.smooth(fitted(md), resid(md)); abline(h=0,lty=2)
  title(i)
  car::qqPlot(resid(md), pch=3, cex=0.5, id=list(n=5, cex=0.7, col="red"), line="quartiles")

}

```
Ok,  residualplots of some models get better. Actually Foxy, Fsol, Phoma, Pult, AMF & Cros are ok. Apha, Fave, Fredo 6 Rsol are still very bad.
I also try some box cox transformations (data not shown), but they are not able to improve the residualplots/the models.

### So, I can try again with the Ranktransformation (ART anova...):

Again, I have to replace the NAs with the treatment mean first, in all of the 10 fungi:

```{r NA replace in qPCR concs, eval=FALSE, echo=FALSE}


```

Here I test the factor replication first          
          
```{r test rep for qPCR, echo=FALSE}

qPCRlistARTrep <- list()   # lists for the ANOVA results with "rep" only as indepedent variable (for loop in this chunk of code)

for (i in thefungis) {
      
      art_model_qPCR_0 <- art(Topf18.FUNGI.MEANS.NONA[[i]] ~ rep, data = Topf18.FUNGI.MEANS.NONA)
      
      print(i)
      print(anova(art_model_qPCR_0))
      
      qPCRlistARTrep[[paste("Anova",i)]] <- anova(art_model_qPCR_0)
      
  }
```

the factor "rep" is significant for Foxy and Cros. So I have to see what I do with that.... !

Then I do the models of interest:

```{r ARTmodel of soil*acc for qPCR}

qPCRlistARTsoilacc <- list() # list for the ANOVA results wit soil*acc as indep. var.

for (i in thefungis) {

    art_model_qPCR <- art(Topf18.FUNGI.MEANS.NONA[[i]] ~ soil*acc, data = Topf18.FUNGI.MEANS.NONA)
    
    print("-------------------------------")
    print(i)
    print(art_model_qPCR)  # everything should be 0
    print(anova(art_model_qPCR))
    
    qPCRlistARTsoilacc[[paste("Anova",i)]] <- anova(art_model_qPCR)
    
}

qPCRlistART <- list(qPCRlistARTrep, qPCRlistARTsoilacc)  # summary list of both lists

#saveRDS(qPCRlistART, "qPCRlistART.4soils.rds") # I exclude this bit cause I saved the rds already

```
So, for all 10 fungis the factors _soil_ and _acc_ and their interaction are significant. In comparison to the (wrong) standard linear regression the factors get "more" significant. And are even significant for Phoma, Pult and Rsol....

### qPCR 10 fungi ART 3 soils only

I redo the same analyses but only ofer the 3 sick soils:

##################
Here I test the factor replication first

```{r subset working DF to 3 soils}
Topf18.FUNGI.MEANS.3SICK.NONA <- filter(Topf18.FUNGI.MEANS.NONA, soil != "F")   # kick out FELDBACH, so that I work only with the 3 sick soils
```

```{r test rep for qPCR 3 soils}

qPCRlistART3soilsrep <- list()   # lists for the ANOVA results with "rep" only as indepedent variable 

for (i in thefungis) {
      
      art_model_qPCR_0 <- art(Topf18.FUNGI.MEANS.3SICK.NONA[[i]] ~ rep, data = Topf18.FUNGI.MEANS.3SICK.NONA)
      
      print(i)
      print(anova(art_model_qPCR_0))
      
      qPCRlistART3soilsrep[[paste("Anova",i)]] <- anova(art_model_qPCR_0)
      
  }
```

as for all 4 soils factor "rep" is significant for Foxy and Cros. But additinoally also for Fsol (just...). Again I have to see what I do with that.... !

Then, agian,  I do the models of interest:

```{r ARTmodel of soil*acc for qPCR  3 sick soils}

qPCRlistART3soilssoilacc <- list() # list for the ANOVA results wit soil*acc as indep. var.

for (i in thefungis) {

    art_model_qPCR <- art(Topf18.FUNGI.MEANS.3SICK.NONA[[i]] ~ soil*acc, data = Topf18.FUNGI.MEANS.3SICK.NONA)
    
    print("-------------------------------")
    print(i)
    print(art_model_qPCR)  # everything should be 0
    print(anova(art_model_qPCR))
    
    qPCRlistART3soilssoilacc[[paste("Anova",i)]] <- anova(art_model_qPCR)
    
}

qPCRlistART3soils <- list(qPCRlistART3soilsrep, qPCRlistART3soilssoilacc)  # summary list of both lists

#saveRDS(qPCRlistART3soils, "qPCRlistART.3soils.rds") # I exclude this bit cause I saved the rds already

```

Still, as with the analysis over 4 soils, here, over the 3 soils soil, acc and soil*acc is always significant. Exception: Rsol interaction term is not significant.

## Multivariat Analysis of the qpCR data

```{r NMDS on qCPR data, echo=FALSE, results="hide"}
# prep "A df*, you only want the scores, no factors
Adf <- Topf18.FUNGI.MEANS.NONA[7:16] 
fung.dist <- vegdist(Adf)


# state the NMDS
fung.mds <- metaMDS(Adf, distance = "bray", k = 2, trymax = 50) #makes the object bci.mds using Bray-Curtis ordination

##pull points from MDS
NMDS1 <- fung.mds$points[,1] 
NMDS2 <- fung.mds$points[,2]
nmds.plot <- cbind(Topf18.FUNGI.MEANS, NMDS1, NMDS2)

# stressplot(my.mds)

# make a nice ordination plot
#plot(fung.mds, type="n") # plots the ordination axes only
#with(Topf18.FUNGI.MEANS, points(fung.mds, display = "sites", col = Kolor[soil], pch = 21, bg = Kolor[soil]))
#with(Topf18.FUNGI.MEANS, legend("topright", legend = levels(soil), bty = "n", col = Kolor, pch = 21, pt.bg = Kolor))
#text(1, -0.6, "Stress = 0.17")

# Vorbereiten der 10 Pfeile f?r den NMDS-Plott
fit <- envfit(fung.mds, Adf) # "envfit" fittet variabeln auf die Ordination; hier einfach meine 10 Pilze
arrow <- data.frame(fit$vectors$arrows, R = fit$vectors$r, P = fit$vectors$pvals)  # Koordinaten der Vektoren der Variabeln
arrow$FG <- rownames(arrow)  # Pilznamen

# also, save the envfit (I do this once, then I exclude the code)
NMDS.envfit_4soils <- fit
NMDS.envfit_4soils <- cbind(fit$vectors$r, fit$vectors$pvals)
colnames(NMDS.envfit_4soils) <- c("r2","p")
#saveRDS(NMDS.envfit_4soils, "NMDS.envfit_4soils.rds")  

# NMDS Plot mit ggplot
ggplot(nmds.plot, aes(NMDS1, NMDS2)) +
    geom_segment(data = arrow, aes(x=0, y=0, xend=NMDS1, yend=NMDS2), alpha=0.2,
                 size = 1, arrow = arrow(length = unit(1, "cm")*(arrow$R)*2)) + # add arrows (arrow head scaled by R-squared value)
    geom_text(data = arrow, aes(x=NMDS1*1.1, y=NMDS2*1.1, label = FG), size=(15*arrow$R)) +
    geom_point(aes(color = soil)) +
    stat_ellipse(aes(fill=soil), alpha=.1, type='t', size =1, geom="polygon") + # 95% CI ellipses
    scale_color_manual(values = Kolor) +
    scale_fill_manual(values = Kolor) +
    annotate("text", x=max(NMDS1), y=-1, label=paste('Stress =',round(fung.mds$stress,2))) + # add stress-value to plot
    theme_classic()

```

```{r PERMANOVA qpCR 4 soils}
# PERMANOVA to test soil*acc
set.seed(3825)
adonis(fung.dist ~ rep + soil*acc, data = Topf18.FUNGI.MEANS)

```
```{r PERMANOVA qpCR 4 soils reslevel}
# PERMANOVA to test soil*reslevel
set.seed(3825)
adonis(fung.dist ~ rep + soil*reslevel, data = Topf18.FUNGI.MEANS)

```

The NMNDS plot shows a pretty nice clustering according to the soils. The PERMANOVA shows sig. effects for soil, rep and the interaction. reslevel is also significant. Rep is not significant. The Total Variance explained by the factors soil & ac (incl. interaction) is ~74% - Cool! The model with reslevel explains only 52%

<br>
#####I also want to see, how the analysis is in the 3 sick soils:

```{r NMDS on qCPR data 3 sick soils, echo = FALSE, results="hide"}
# prep "A df*, you only want the scores, no factors
Adf <- Topf18.FUNGI.MEANS.3SICK.NONA[7:16]
fung.dist <- vegdist(Adf)


# state the NMDS
fung.mds <- metaMDS(Adf, distance = "bray", k = 2, trymax = 50) #makes the object bci.mds using Bray-Curtis ordination

##pull points from MDS
NMDS1 <- fung.mds$points[,1] ##also found using scores(birdMDS)
NMDS2 <- fung.mds$points[,2]
nmds.plot <- cbind(Topf18.FUNGI.MEANS.3SICK, NMDS1, NMDS2)

# Vorbereiten der 10 Pfeile f?r den NMDS-Plott
fit <- envfit(fung.mds, Adf) # "envfit" fittet variabeln auf die Ordination; hier einfach meine 10 Pilze
arrow <- data.frame(fit$vectors$arrows, R = fit$vectors$r, P = fit$vectors$pvals)  # Koordinaten der Vektoren der Variabeln
arrow$FG <- rownames(arrow)  # Pilznamen

# also, save the envfit (I do this once manually, then I exclude the code)
NMDS.envfit_3soils <- fit
NMDS.envfit_3soils <- cbind(fit$vectors$r, fit$vectors$pvals)
colnames(NMDS.envfit_3soils) <- c("r2","p")
#saveRDS(NMDS.envfit_3soils, "NMDS.envfit_3soils.csv")

  
# NMDS Plot mit ggplot
ggplot(nmds.plot, aes(NMDS1, NMDS2)) +
    geom_segment(data = arrow, aes(x=0, y=0, xend=NMDS1, yend=NMDS2), alpha=0.2,
                 size = 1, arrow = arrow(length = unit(1, "cm")*(arrow$R)*2)) + # add arrows (arrow head scaled by R-squared value)
    geom_text(data = arrow, aes(x=NMDS1*1.1, y=NMDS2*1.1, label = FG), size=(15*arrow$R)) +
    geom_point(aes(color = soil)) +
    stat_ellipse(aes(fill=soil), alpha=.1, type='t', size =1, geom="polygon") + # 95% CI ellipses
    scale_color_manual(values = Kolor[2:4]) +
    scale_fill_manual(values = Kolor[2:4]) +
    annotate("text", x=max(NMDS1), y=-1, label=paste('Stress =',round(fung.mds$stress,2))) + # add stress-value to plot
    theme_classic()

```

```{r PERMANOVA qPCR 3soils}
set.seed(3825)
Topf18perm <- adonis(fung.dist ~ rep + soil*acc, data = Topf18.FUNGI.MEANS.3SICK)
Topf18perm
```

When F ist not in the analysis I still have significant soil, acc & interaction effects. So now: How can I invesigate the acc effect more. First, I try to make NMDS and PERMANOVA within each of the 4 soils for the genotypes.... :)


```{r r qPCR NMDS within 3 sick soils individually, echo=FALSE, results="hide"}
#### Loop over 3 sick soils to produce 3 plot panles

set.seed(3825)
thesoils <- levels(Topf18.FUNGI$soil)

fitlist3soilsindivid <- list() #initiate an empty list for the envfits
plotlist <- list() #initiate an empty list for the plots

for (i in (thesoils[2:4])) {   # the permutation for the "F" - soil does not work somehow, thats why I only do the NMDS for the three sick soils
  
  # prep "Adf", you only want the scores, no factors
  Adf <- Topf18.FUNGI.MEANS.NONA[Topf18.FUNGI.MEANS.NONA$soil== i,7:16] 
  fung.dist <- vegdist(Adf)
  
  # calcualte PERMANOVA and get p for genotype (acc) effect & reslevel effect
  Pacc <- adonis2(fung.dist ~ rep + acc, data = Topf18.FUNGI.MEANS[Topf18.FUNGI.MEANS$soil== i,])[2,5]
  Preslevel <- adonis2(fung.dist ~ rep + reslevel, data = Topf18.FUNGI.MEANS[Topf18.FUNGI.MEANS$soil== i,])[2,5]
  
  
  # state the NMDS
  fung.mds <- metaMDS(Adf, distance = "bray", k = 2, trymax = 50) #makes the object bci.mds using Bray-Curtis ordination
  
  ##pull points from MDS
  NMDS1 <- fung.mds$points[,1] ##also found using scores(birdMDS)
  NMDS2 <- fung.mds$points[,2]
  nmds.plot <- cbind(Topf18.FUNGI.MEANS[Topf18.FUNGI.MEANS$soil== i,], NMDS1, NMDS2)
  
  # Vorbereiten der 10 Pfeile fuer den NMDS-Plott
  fit <- envfit(fung.mds, Adf) # "envfit" fittet variabeln auf die Ordination; hier einfach meine 10 Pilze
  arrow <- data.frame(fit$vectors$arrows, R = fit$vectors$r, P = fit$vectors$pvals)  # Koordinaten der Vektoren der Variabeln
  arrow$FG <- rownames(arrow)  # Pilznamen
  
  # also, store & save the envfits in the list 
  fitlist3soilsindivid[[i]] <- fit
  #saveRDS(fitlist3soilsindivid, "NMDS.envfit_in3soilsindividually.rds")   #(I do this once manually, then I exclude the code)
  
  
  
  # NMDS Plot mit ggplot
  
  ifelse(i == "H", kl <- Kolor[2], ifelse(i == "L", kl <-  Kolor[3], ifelse(i == "W", kl <-  Kolor[4])))
  
  g <- ggplot(nmds.plot, aes(NMDS1, NMDS2)) +
    geom_point(aes(shape = acc), color = kl) +
    scale_shape_manual(values = c(15, 0, 19, 1, 17, 2, 20, 18)) +
    stat_ellipse(aes(lty=factor(reslevel)), alpha=0.3, size = 0.5, geom = "polygon", color = kl, fill = kl) +
    #scale_color_manual(values = c("gray80", "grey27"), guide = FALSE) +
    annotate("text", -Inf, Inf, label=paste("Stress =", round(fung.mds$stress,2)), hjust = -0.2, vjust = 3) +
    annotate("text", -Inf, Inf, label=paste("reslevel: p = ", Preslevel), hjust = -0.15, vjust = 6) +
    annotate("text", -Inf, Inf, label=paste("acc: p = ", Pacc), hjust = -0.2, vjust = 8) +
    ggtitle(i) +
    theme_bw() +
    theme(legend.title = element_blank(),
          panel.background =  element_blank(),
          panel.grid = element_blank()) +
    guides(shape = guide_legend(ncol = 2))
  
  
  plotlist[[i]] <- g
}


## Plot the 3 panels with the legend in a fourth panel
thelegend <- ggpubr::get_legend(plotlist$H + theme(legend.box.margin = margin(0, 0, 0, 0))) # extract the legend from one of the plots

prow <- cowplot::plot_grid(
  plotlist$H + theme(legend.position="none"),
  plotlist$L + theme(legend.position="none"),
  plotlist$W + theme(legend.position="none"),
  thelegend,
  hjust = -1,
  nrow = 2
)
prow

```


<br>
#####PERMANOVA to test factor "acc" in each soil individually:
```{r PERMANOVA on acc within 4 soils, echo=FALSE}
set.seed(3825)
for (i in (thesoils)) {
  
  Adf <- Topf18.FUNGI.MEANS.NONA[Topf18.FUNGI.MEANS.NONA$soil== i,7:16] 
  fung.dist <- vegdist(Adf)
                       
  permi <- adonis(fung.dist ~ rep + acc, data = Topf18.FUNGI.MEANS[Topf18.FUNGI.MEANS$soil== i,])
  print("------------------------------------------")
  print(i)
  print(permi)

}

```
<br>
The PERMANOVA within each soil individuall look squite nice. 83/65/48/55 % explained by genotype respectively. In "W" also Rep is significant....
<br>
<br>



##### PERMANOVA to test factor "reslevel" in each soil individually:
```{r PERMANOVA on reslevel within 4 soils, echo=FALSE}
for (i in (thesoils)) {
  
  Adf <- Topf18.FUNGI.MEANS.NONA[Topf18.FUNGI.MEANS.NONA$soil== i,7:16] 
  fung.dist <- vegdist(Adf)
                       
  permi <- adonis2(fung.dist ~ rep + reslevel, data = Topf18.FUNGI.MEANS[Topf18.FUNGI.MEANS$soil== i,])
  print("------------------------------------------")
  print(i)
  print(permi)

  
}
```

But actually it would be right to do the full model with acc + reslevel at the same time:
-> NOTE: The variance explained by each of the factors individually is the same, together they sum up to the variance explained by acc in the simple model.... :).

I use this info for the publication...
```{r PERMANOVA within soils reslevel-acc}
for (i in (thesoils)) {
  
  Adf <- Topf18.FUNGI.MEANS.NONA[Topf18.FUNGI.MEANS.NONA$soil== i,7:16] 
  fung.dist <- vegdist(Adf)
  
  permi <- adonis(fung.dist ~ rep + reslevel + acc, data = Topf18.FUNGI.MEANS[Topf18.FUNGI.MEANS$soil== i,])
  print("------------------------------------------")
  print(i)
  print(permi)
  
  
}

```


##Analysis of most important Fungi

I reconsider the envfit objects for the overall (4 soils), 3 soils, and individual soils ndms, to see which fungus is important in separating the factors (soil or acc)

```{r reconsider envfits}
# I sort the fungi withing the the different analysis according to their r in the envfit

#NMDS.envfit_4soils
#NMDS.envfit_3soils

NMDS.envfit_H <- fitlist3soilsindivid$H       # get enffit for only H soil from the list
NMDS.envfit_H <- cbind(NMDS.envfit_H$vectors$r, NMDS.envfit_H$vectors$pvals)       # just extract r and p-value for each fungus
colnames(NMDS.envfit_H) <- c("r2","p")


NMDS.envfit_L <- fitlist3soilsindivid$L
NMDS.envfit_L <- cbind(NMDS.envfit_L$vectors$r, NMDS.envfit_L$vectors$pvals)
colnames(NMDS.envfit_L) <- c("r2","p")

NMDS.envfit_W <- fitlist3soilsindivid$W
NMDS.envfit_W <- cbind(NMDS.envfit_W$vectors$r, NMDS.envfit_W$vectors$pvals)
colnames(NMDS.envfit_W) <- c("r2","p")


ENVfit_4 <- arrange(data.frame(Fungus = row.names(NMDS.envfit_4soils), NMDS.envfit_4soils), desc(r2))   # do the sorting of the r's 
ENVfit_3 <- arrange(data.frame(Fungus = row.names(NMDS.envfit_3soils), NMDS.envfit_3soils), desc(r2))
ENVfit_H <- arrange(data.frame(Fungus = row.names(NMDS.envfit_H), NMDS.envfit_H), desc(r2))
ENVfit_L <- arrange(data.frame(Fungus = row.names(NMDS.envfit_L), NMDS.envfit_L), desc(r2))
ENVfit_W <- arrange(data.frame(Fungus = row.names(NMDS.envfit_W), NMDS.envfit_W), desc(r2))

ENVfit_fungi_list <- list(ENVfit_4, ENVfit_3, ENVfit_H, ENVfit_L, ENVfit_W)
names(ENVfit_fungi_list) <- c("ENVfit_4", "ENVfit_3", "ENVfit_H", "ENVfit_L", "ENVfit_W")
#lapply(ENVfit_fungi_list, function(x) write.table(data.frame(x), 'Topf18_ENVfit_fungis43HLW.csv', append= T, sep=','))


```

Observations: a) Over all soils all Fungi are significant; Apha, Fsol, AMF and Foxy have highest r. b) Looking only at the 3 sick soils, AMF, Fsol, Cros, Apha & Foxy have high r. c) In H, Fave, AMF, Foxy, Cros & Fsol have high r; interestingly, Apha is not significant with very low r. d) In L, Fredo has highest r, then AMF, Fsol & Fave. e) In W, again, Fave has high r, then Fredo, Cros, Foxy; Fsol & Apha have r around 0.2 and are just significant (p=0.03).

<br>

##Relationship between fungal abundance and phenotype
### Correaltions between fungal quanatifications and SDWrel.

```{r Corr qPCR - SDWRel, warning=FALSE, echo=FALSE}
xxx <- Topf18.COMBO.NS[,c(1,3,4,5,27:37)]
xxx.long <- melt(xxx, id = c("LABEL", "acc", "soil", "reslevel"))   #prep data


dotplot_fun <- function(x)  {   # Dot-Plot function, die x annehmen kann; x sind die 10 Namen der Fungi in response
  
  sudat <- xxx.long %>% filter(variable == x | variable == "s.dw.ratioSNS")
  sudat.wide <- dcast(sudat, LABEL~variable)
  sudat.wide <- merge(sudat.wide, sudat[,1:4], by="LABEL")   #further prep data
  colnames(sudat.wide)[c(2,3)] <- c("x", "y")
  
  rho4 <- round(cor.test(sudat.wide$x, sudat.wide$y, use = "complete", method="spearman")$estimate,2)   #calcualte  Spearman corrs. over all 4                 soils - to display it in the plots below
  p4 <- round(cor.test(sudat.wide$x, sudat.wide$y, use = "complete", method="spearman")$p.value,2)
  
  # Make a dotplot
  ggplot(sudat.wide, aes(x = x, y = y, color=soil)) +
  geom_point() +
  scale_color_manual(values=Kolor) +
  geom_smooth(method = "loess", span=1, se=FALSE) +
  theme_bw() +
  theme(legend.position = "none",
        axis.title = element_blank()) +
  annotate("text", x = Inf, y = Inf, label = x,  hjust = 1, vjust = 1) +
  annotate("text", x = Inf, y = Inf, label = rho4,  hjust = 1, vjust = 2) +
  annotate("text", x = Inf, y = Inf, label = p4,  hjust = 1, vjust = 3)
  
  
  
}

TenFungiPlot2 <- map(thefungis, ~dotplot_fun(.x))   #loop over (Purr::map) thefungis
cowplot::plot_grid(plotlist = TenFungiPlot2, ncol = 3)

# Remove all temp objects!
rm(xxx, xxx.long,sudat, sudat.wide, TenFungiPlot2, dotplot_fun)

```

I redo the sam for the 3 sick soils only, for better visualization:
```{r corr plot 3 sick soils only, echo=FALSE, warning=FALSE}

# ACHTUNG: Die hmisc::corrmat() rechnet die p-values anders als cor.test() -> heisst ich habe im Grapghen der Publikation ein zwei Korrelationen  (z.B. P. ult in H) nicht drin... ;)

xxx <- Topf18.COMBO.NS[Topf18.COMBO.NS$soil!="F", c(1,3,4,5,27:37)]   # take out Feldbach
xxx <- droplevels(xxx)
xxx.long <- melt(xxx, id = c("LABEL", "acc", "soil", "reslevel"))   #prep data

dotplot_fun <- function(x)  {   # Dot-Plot function, die x annehmen kann; x sind die 10 Namen der Fungi in response
  
  sudat <- xxx.long %>% filter(variable == x | variable == "s.dw.ratioSNS")
  sudat.wide <- dcast(sudat, LABEL~variable)
  sudat.wide <- merge(sudat.wide, sudat[,1:4], by="LABEL")   #further prep data
  colnames(sudat.wide)[c(2,3)] <- c("x", "y")
  
  rho3 <- round(cor.test(sudat.wide$x, sudat.wide$y, use = "complete", method="spearman")$estimate,2)   #calcualte  Spearman corrs. over all 4                 soils - to display it in the plots below
  p3 <- round(cor.test(sudat.wide$x, sudat.wide$y, use = "complete", method="spearman")$p.value,2)
  
  # Make a dotplot
  ggplot(sudat.wide, aes(x = x, y = y, color=soil)) +
  geom_point() +
  scale_color_manual(values=Kolor[2:4]) +
  geom_smooth(method = "lm", se=FALSE) +
  theme_bw() +
  theme(legend.position = "none",
        axis.title = element_blank()) +
  annotate("text", x = Inf, y = Inf, label = x,  hjust = 1, vjust = 1) +
  annotate("text", x = Inf, y = Inf, label = rho3,  hjust = 1, vjust = 2) +
  annotate("text", x = Inf, y = Inf, label = p3,  hjust = 1, vjust = 3)
  
}


TenFungiPlot3 <- map(thefungis, ~dotplot_fun(.x))   #loop over (Purr::map) thefungis
cowplot::plot_grid(plotlist = TenFungiPlot3, ncol = 3)

# Remove all temp objects!
rm(xxx, xxx.long,sudat, sudat.wide, TenFungiPlot3, dotplot_fun)

```


Calculate the correlations between the abundance of the 10 fungi and SDWrel. :

```{r Corr 10 Fungi SDWrel, echo=FALSE, warning=FALSE}

xxx <- Topf18.COMBO.NS[,c(1,3,4,5,27,28:37)]     # Kol 27 ist SDW
xxx.long <- melt(xxx, id = c("LABEL", "acc", "soil", "reslevel"))   #prep data

corrs_fun <- function(x)  {   # Dot-Plot function, die x annehmen kann; x sind die 10 Namen der Fungi in response
  
  sudat <- xxx.long %>% filter(variable == x | variable == "s.dw.ratioSNS")
  sudat.wide <- dcast(sudat, LABEL~variable)
  sudat.wide <- merge(sudat.wide, sudat[,1:4], by="LABEL")   #further prep data
  colnames(sudat.wide)[c(2,3)] <- c("x", "y")
  
  rho4 <- round(cor.test(sudat.wide$x, sudat.wide$y, use = "complete", method="spearman")$estimate,2)     #calcualte  Spearman corrs. over all 4                 soils - to display it in the plots below
  p4 <- round(cor.test(sudat.wide$x, sudat.wide$y, use = "complete", method="spearman")$p.value,2)
  rho3 <- round(cor.test(sudat.wide[sudat.wide$soil!="F",]$x,
                          sudat.wide[sudat.wide$soil!="F",]$y, use = "complete",
                          method="spearman")$estimate,2)       #also calc corrs over 3 sick soils
  p3 <- round(cor.test(sudat.wide[sudat.wide$soil!="F",]$x,
                          sudat.wide[sudat.wide$soil!="F",]$y, use = "complete",
                          method="spearman")$p.value,4)
  
  rhoH <- round(cor.test(sudat.wide[sudat.wide$soil=="H",]$x,
                          sudat.wide[sudat.wide$soil=="H",]$y, use = "complete",
                          method="spearman")$estimate,2)   #also calc corrs for H
  pH <- round(cor.test(sudat.wide[sudat.wide$soil=="H",]$x,
                          sudat.wide[sudat.wide$soil=="H",]$y, use = "complete",
                          method="spearman")$p.value,4)
  
  rhoL <- round(cor.test(sudat.wide[sudat.wide$soil=="L",]$x,
                          sudat.wide[sudat.wide$soil=="L",]$y, use = "complete",
                          method="spearman")$estimate,2)   #also calc corrs for L
  pL <- round(cor.test(sudat.wide[sudat.wide$soil=="L",]$x,
                          sudat.wide[sudat.wide$soil=="L",]$y, use = "complete",
                          method="spearman")$p.value,4)
  
  rhoW <- round(cor.test(sudat.wide[sudat.wide$soil=="W",]$x,
                          sudat.wide[sudat.wide$soil=="W",]$y, use = "complete",
                          method="spearman")$estimate,2)   #also calc corrs for W
  pW <- round(cor.test(sudat.wide[sudat.wide$soil=="W",]$x,
                          sudat.wide[sudat.wide$soil=="W",]$y, use = "complete",
                          method="spearman")$p.value,4)
  
  # save all these values in the list
  dd <- as.data.frame(cbind(c(rho4, rho3, rhoH, rhoL, rhoW), c(p4, p3, pH, pL, pW)))
  rownames(dd) <- c("4soils", "3sick", "H", "L", "W")
  colnames(dd) <- c("rho", "p.value")
  
  dd$stars <- cut(dd$p.value, breaks=c(-Inf, 0.001, 0.01, 0.05, Inf),
                  label=c("***", "**", "*", "ns"))  #       Create column of significance labels
  dd
}

(corr_summary_fungiSDW_list <- map(thefungis, ~corrs_fun(.x)))   #loop over (Purr::map) thefungis

#lapply(corr_summary_fungiSDW_list, function(x) write.table(data.frame(x), 'Topf18_corr_summary_fungiSDW_list.csv', append= T, sep=','))    #save list as a table

# Remove all temp objects!
rm(xxx, xxx.long, corrs_fun, sudat, sudat.wide, rho4, rho3, rhoH, rhoL, rhoW, dd)












```


I try to summarize the most stricking patterns:
There is a significant negative correlation over all 4 soils for Apha, Fave, Fsol, Rsol & Cros. There is a sig. positive for Pult and AMF. However Pult shows no sig. pos corr in any of the subsets... only a sig. negative corr in H.
<br>
Over the 3 sick soils and within the sick soils: Apha shows a sig. neg corr, that remains only in L individually. The exact same hold true for Fave. Interestingly, Foxy shows no corr over the 3 sick soils, but significant neg corrs in H and L. Fredo has a sig pos corr over the 3 sick soils; Spearman indicates a barely sig neg corr in H although from the plot it seeems more that W has a pos corr (which is not sign...). Fsol has a sig neg corr over the 3 sick soils, which holds in H & L. In W it is non-sig a positive. Phoma has a sig neg corr in H, everythin gelse is non-sig. Pult has a weak but sig neg corr in H only. Rsol has sig neg corrs in L & W (just not sig in H). AMF showsclear and significant pos corrs in all 3 sick soils. Cros shows no significant corr over the 3 sick soils, only in L a sig neg.

<br>

No lets claculate the same correlations for RRI:

```{r Corr fungi with RRI, echo=FALSE, warning=FALSE}
xxx <- Topf18.COMBO.NS[,c(1,3,4,5,17,28:37)]
xxx.long <- melt(xxx, id = c("LABEL", "acc", "soil", "reslevel"))   #prep data

corrs_fun <- function(x)  {   # Dot-Plot function, die x annehmen kann; x sind die 10 Namen der Fungi in response
  
  sudat <- xxx.long %>% filter(variable == x | variable == "r.aspectMEDIAN")
  sudat.wide <- dcast(sudat, LABEL~variable)
  sudat.wide <- merge(sudat.wide, sudat[,1:4], by="LABEL")   #further prep data
  colnames(sudat.wide)[c(2,3)] <- c("x", "y")
  
  rho4 <- round(cor.test(sudat.wide$x, sudat.wide$y, use = "complete", method="spearman")$estimate,2)     #calcualte  Spearman corrs. over all 4                 soils - to display it in the plots below
  p4 <- round(cor.test(sudat.wide$x, sudat.wide$y, use = "complete", method="spearman")$p.value,2)
  rho3 <- round(cor.test(sudat.wide[sudat.wide$soil!="F",]$x,
                          sudat.wide[sudat.wide$soil!="F",]$y, use = "complete",
                          method="spearman")$estimate,2)       #also calc corrs over 3 sick soils
  p3 <- round(cor.test(sudat.wide[sudat.wide$soil!="F",]$x,
                          sudat.wide[sudat.wide$soil!="F",]$y, use = "complete",
                          method="spearman")$p.value,4)
  
  rhoH <- round(cor.test(sudat.wide[sudat.wide$soil=="H",]$x,
                          sudat.wide[sudat.wide$soil=="H",]$y, use = "complete",
                          method="spearman")$estimate,2)   #also calc corrs for H
  pH <- round(cor.test(sudat.wide[sudat.wide$soil=="H",]$x,
                          sudat.wide[sudat.wide$soil=="H",]$y, use = "complete",
                          method="spearman")$p.value,4)
  
  rhoL <- round(cor.test(sudat.wide[sudat.wide$soil=="L",]$x,
                          sudat.wide[sudat.wide$soil=="L",]$y, use = "complete",
                          method="spearman")$estimate,2)   #also calc corrs for L
  pL <- round(cor.test(sudat.wide[sudat.wide$soil=="L",]$x,
                          sudat.wide[sudat.wide$soil=="L",]$y, use = "complete",
                          method="spearman")$p.value,4)
  
  rhoW <- round(cor.test(sudat.wide[sudat.wide$soil=="W",]$x,
                          sudat.wide[sudat.wide$soil=="W",]$y, use = "complete",
                          method="spearman")$estimate,2)   #also calc corrs for W
  pW <- round(cor.test(sudat.wide[sudat.wide$soil=="W",]$x,
                          sudat.wide[sudat.wide$soil=="W",]$y, use = "complete",
                          method="spearman")$p.value,4)
  
  # save all these values in the list
  dd <- as.data.frame(cbind(c(rho4, rho3, rhoH, rhoL, rhoW), c(p4, p3, pH, pL, pW)))
  rownames(dd) <- c("4soils", "3sick", "H", "L", "W")
  colnames(dd) <- c("rho", "p.value")
  
  dd$stars <- cut(dd$p.value, breaks=c(-Inf, 0.001, 0.01, 0.05, Inf),
                  label=c("***", "**", "*", "ns"))  #       Create column of significance labels
  dd
}

(corr_summary_fungiRRI_list <- map(thefungis, ~corrs_fun(.x)))   #loop over (Purr::map) thefungis

#lapply(corr_summary_fungiRRI_list, function(x) write.table(data.frame(x), 'Topf18_summary_corr_fungiRRI_list.csv', append= T, sep=','))    #save list as a table

# Remove all temp objects!
rm(xxx, xxx.long, corrs_fun, sudat, sudat.wide, rho4, rho3, rhoH, rhoL, rhoW, dd)

```
 
The correlations between RRI and the fungal quantities show the ame picture. The sign (+/-) is different for the rho (logically) and the significance are more or less the same; actually the pattern of significance along the groups (4, 3, H, L, W) is exactly the same but for Phoma, Pult & Rsol (the 3 "Wackelkandidaten"). - I did this comparison in an Excel with highlighted cells.
<br>

Redo a NMDS with the variables RRI and SDWrel in the ENVFIT

```{r NMDS on qCPR data with pheno-envfit, echo=FALSE}
# prep "A df*, you only want the scores, no factors
Adf <- Topf18.COMBO.NS.NONA[28:37]
fung.dist <- vegdist(Adf)


# state the NMDS
fung.mds <- metaMDS(Adf, distance = "bray", k = 2, trymax = 50) # makes the object fung.mds using Bray-Curtis ordination

##pull points from MDS
NMDS1 <- fung.mds$points[,1] 
NMDS2 <- fung.mds$points[,2]
nmds.plot <- cbind(Topf18.COMBO.NS.NONA, NMDS1, NMDS2)

# Vorbereiten der 2 Pfeile fuer den NMDS-Plott
fit <- envfit(fung.mds,  Topf18.COMBO.NS.NONA[,c(11,12,13,15,17,20,26,27:37)], na.rm=TRUE) # "envfit" mit fungis und phenos
arrow <- data.frame(fit$vectors$arrows, R = fit$vectors$r, P = fit$vectors$pvals)  # Koordinaten der Vektoren der Variabeln
arrow$FG <- rownames(arrow)  # Pilznamen

# also, save the envfit (I do this once, then I exclude the code)
NMDS.envfit_4soils_pheno <- fit
NMDS.envfit_4soils_pheno <- cbind(fit$vectors$r, fit$vectors$pvals)
colnames(NMDS.envfit_4soils_pheno) <- c("r2","p")
NMDS.envfit_4soils_pheno
#write.csv(NMDS.envfit_4soils_pheno, "NMDS.envfit_4soils_pheno.csv")
#saveRDS(NMDS.envfit_4soils_pheno, "NMDS.envfit_4soils_pheno.rds")


# NMDS Plot mit ggplot
ggplot(nmds.plot, aes(NMDS1, NMDS2)) +
    geom_segment(data = arrow, aes(x=0, y=0, xend=NMDS1, yend=NMDS2), alpha=1,
                 size = 0.5, arrow = arrow(length = unit(0.2, "cm"))) + # add arrows for fungis and phenos
    geom_text(data = arrow, aes(x=NMDS1*1.1, y=NMDS2*1.1, label = FG)) +
    geom_point(aes(color = soil)) +
    stat_ellipse(aes(fill=soil), alpha=.1, type='t', size =1, geom="polygon") + # 95% CI ellipses
    scale_color_manual(values = Kolor) +
    scale_fill_manual(values = Kolor) +
    annotate("text", x=max(NMDS1), y=-1, label=paste('Stress =', round(fung.mds$stress,2))) + # add stress-value to plot
    theme_classic()

rm(NMDS.envfit_4soils_pheno, fit, arrow, NMDS1, NMDS2, fung.mds, fung.dist, Adf)

```
Somehow the plot is mirrored at the x-axis,but shows the same as the plot without the pheno variables.Adding some phenotype variables to the ENVFIT shows: rel. biomass points in opposite direction than Apha, Fave & Fsol; wilt points together with Apha & Fave; disHeight and RRI are correlated.
No.pl correlates very badly with the ordination. dis.height is very high (0.6), so is RRI (0.53) & rel biomass (0.27 for dry & 0.4 for fresh!). The r2 of the fungi change by 0.01, compared to the envfit with only fungi
<br>


Now, the same again for 3 sick soils
```{r NMDS on qCPR data with pheno-envfit 3 sick soils, echo=FALSE}
# prep "A df*, you only want the scores, no factors
Adf <- Topf18.COMBO.NS.NONA[Topf18.COMBO.NS.NONA$soil!="F",28:37]
fung.dist <- vegdist(Adf)


# state the NMDS
fung.mds <- metaMDS(Adf, distance = "bray", k = 2, trymax = 50, ) # makes the object fung.mds using Bray-Curtis ordination

##pull points from MDS
NMDS1 <- fung.mds$points[,1] 
NMDS2 <- fung.mds$points[,2]
nmds.plot <- cbind(Topf18.COMBO.NS.NONA[Topf18.COMBO.NS.NONA$soil!="F",], NMDS1, NMDS2)

# Vorbereiten der 2 Pfeile fuer den NMDS-Plott
fit <- envfit(fung.mds,  Topf18.COMBO.NS.NONA[Topf18.COMBO.NS.NONA$soil!="F",c(11,12,13,15,17,20,26,27:37)], na.rm=TRUE) # "envfit" mit fungis und phenos
arrow <- data.frame(fit$vectors$arrows, R = fit$vectors$r, P = fit$vectors$pvals)  # Koordinaten der Vektoren der Variabeln
arrow$FG <- rownames(arrow)  # Pilznamen

# also, save the envfit (I do this once, then I exclude the code)
NMDS.envfit_3soils_pheno <- fit
NMDS.envfit_3soils_pheno <- cbind(fit$vectors$r, fit$vectors$pvals)
colnames(NMDS.envfit_3soils_pheno) <- c("r2","p")
NMDS.envfit_3soils_pheno
#write.csv(NMDS.envfit_3soils_pheno, "NMDS.envfit_3soils_pheno.csv")
#saveRDS(NMDS.envfit_3soils_pheno, "NMDS.envfit_3soils_pheno.rds")


# NMDS Plot mit ggplot
ggplot(nmds.plot, aes(NMDS1, NMDS2)) +
    geom_segment(data = arrow, aes(x=0, y=0, xend=NMDS1, yend=NMDS2), alpha=1,
                 size = 0.5, arrow = arrow(length = unit(0.2, "cm"))) + # add arrows for fungis and phenos
    geom_text(data = arrow, aes(x=NMDS1*1.1, y=NMDS2*1.1, label = FG)) +
    geom_point(aes(color = soil)) +
    stat_ellipse(aes(fill=soil), alpha=.1, type='t', size =1, geom="polygon") + # 95% CI ellipses
    scale_color_manual(values = Kolor[2:4]) +
    scale_fill_manual(values = Kolor[2:4]) +
    annotate("text", x=max(NMDS1), y=-1, label=paste('Stress =', round(fung.mds$stress,2))) + # add stress-value to plot
    theme_classic()


rm(NMDS.envfit_3soils_pheno, fit, arrow, NMDS1, NMDS2, fung.mds, fung.dist, Adf)

```
OK, same picture as over the 4 soils and without geno variables. Stress is 0.22, rather high.

Now, only individually 3 sick soils

```{r qPCR NMDS within 3 sick soils individually with pheno, echo=FALSE, results="hide"}
#### Loop over 3 sick soils to produce 3 plot panles

set.seed(3825)
thesoils <- levels(Topf18.FUNGI$soil)

fitlist3soilsindivid_pheno <- list() #initiate an empty list for the envfits
plotlist <- list() #initiate an empty list for the plots

for (i in (thesoils[2:4])) {   # the permutation for the "F" - soil does not work somehow, thats why I only do the NMDS for the three sick soils
  
  # prep "Adf", you only want the scores, no factors
  Adf <- Topf18.COMBO.NS.NONA[Topf18.COMBO.NS.NONA$soil==i, c(28:37)] 
  fung.dist <- vegdist(Adf)
  
  # state the NMDS
  fung.mds <- metaMDS(Adf, distance = "bray", k = 2, trymax = 50) #makes the object bci.mds using Bray-Curtis ordination
  
  ##pull points from MDS
  NMDS1 <- fung.mds$points[,1] ##also found using scores(birdMDS)
  NMDS2 <- fung.mds$points[,2]
  nmds.plot <- cbind(Topf18.COMBO.NS.NONA[Topf18.COMBO.NS.NONA$soil==i, c(3,4,7,11,12,13,15,17,20,26,27:37)], NMDS1, NMDS2)
  
  # Vorbereiten der 10 Pfeile fuer den NMDS-Plott
  fit <- envfit(fung.mds, Topf18.COMBO.NS.NONA[Topf18.COMBO.NS.NONA$soil==i, c(3,4,5,11,12,13,15,17,20,26,27:37)],  na.rm=TRUE) # "envfit" fittet variabeln auf die Ordination; hier einfach meine 10 Pilze
  arrow <- data.frame(fit$vectors$arrows, R = fit$vectors$r, P = fit$vectors$pvals)  # Koordinaten der Vektoren der Variabeln
  arrow$FG <- rownames(arrow)  # Pilznamen
  
  # also, store & save the envfits in the list 
  fitlist3soilsindivid_pheno[[i]] <- fit
  #saveRDS(fitlist3soilsindivid_pheno, "fitlist3soilsindivid_pheno.rds")   #(I do this once manually, then I exclude the code)
  
  
  
  # NMDS Plot mit ggplot
  
  ifelse(i == "H", kl <- "#990000", ifelse(i == "L", kl <- "#CC6600", ifelse(i == "W", kl <- "#663333")))
  
  g <- ggplot(nmds.plot, aes(NMDS1, NMDS2)) +
    geom_point(aes(shape = acc), color = kl) +
    geom_segment(data = arrow, aes(x=0, y=0, xend=NMDS1, yend=NMDS2), alpha=1,
                 size = 0.5, arrow = arrow(length = unit(0.2, "cm"))) + # add arrows for fungis and phenos
    geom_text(data = arrow, aes(x=NMDS1*1.1, y=NMDS2*1.1, label = FG)) +
    scale_shape_manual(values = c(15, 0, 19, 1, 17, 2, 20, 18)) +
    stat_ellipse(aes(lty=factor(reslevel)), alpha=0.3, size = 0.5, geom = "polygon", color = kl, fill = kl) +
    #scale_color_manual(values = c("gray80", "grey27"), guide = FALSE) +
    annotate("text", -Inf, Inf, label=paste("Stress =", round(fung.mds$stress,2)), hjust = -0.2, vjust = 3) +
    #annotate("text", -Inf, Inf, label=paste("reslevel: p = ", Preslevel), hjust = -0.15, vjust = 6) +
    #annotate("text", -Inf, Inf, label=paste("acc: p = ", Pacc), hjust = -0.2, vjust = 8) +
    ggtitle(i) +
    theme_bw() +
    theme(legend.title = element_blank(),
          panel.background =  element_blank(),
          panel.grid = element_blank()) +
    guides(shape = guide_legend(ncol = 2))
  
  
  plotlist[[i]] <- g
}


## Plot the 3 panles with the legend in a fourth panel
thelegend <- ggpubr::get_legend(plotlist$H + theme(legend.box.margin = margin(0, 0, 0, 0))) # extract the legend from one of the plots

prow <- cowplot::plot_grid(
  plotlist$H + theme(legend.position="none"),
  plotlist$L + theme(legend.position="none"),
  plotlist$W + theme(legend.position="none"),
  thelegend,
  hjust = -1,
  nrow = 2
)
prow

```


## Fungal quants resistant vs susceptible

```{r fungal quants res vs susc, echo=FALSE, warning=FALSE}

### first some summaries:

sum_Reslvele_list <- list()

       sum_Reslvele_list[["Rsol"]] <- Topf18.COMBO.NS %>% group_by(reslevel) %>%
  summarise(N = sum(!is.na(Rsol)),
                mean= mean(Rsol, na.rm = TRUE),
                   sd = sd(Rsol, na.rm = TRUE))


lapply(sum_Reslvele_list, function(x) write.table(data.frame(x), 'Topf18_summary_N_mean_sd_PhenoFungi_Reslevel.csv', append= T, sep=','))  #... and export it


### Boxplot 2 RESLEVEL (Soil als Farbe) fuer Fsol, qAMF, Fave und Apha - NUR 3 SICKSOILS - MIT schoenem LOOP

Topf18.COMBO.NS$acc <- factor(Topf18.COMBO.NS$acc, c("C1", "S91", "S134", "S64", "G78", "C2", "S22", "G89"))  # put genotypes in right order for plotting

expl = names(Topf18.COMBO.NS)[c(3,4,7)]  # mögliche Explanatoryvariablen (x), wie acc, soil usw
response = names(Topf18.COMBO.NS)[c(17,27:37)]  # mögliche Responsvariabeln (y); hier nur qAMF, Fsol und Apha
response = set_names(response)    #Purrr Package for set_names function
expl = set_names(expl)

Topf18.COMBO.3SICK <- Topf18.COMBO.NS[Topf18.COMBO.NS$soil!="F",]

boxplot_fun = function(x, y) {   # Plot function, die x und y annehmen kann - ACHTUNG log10 der Werte   ///&%ç
  
  
  p <- wilcox.test(Topf18.COMBO.3SICK[Topf18.COMBO.3SICK$reslevel=="R" , ][[y]], Topf18.COMBO.3SICK[Topf18.COMBO.3SICK$reslevel=="S", ][[y]])$p.value

  #print(paste("P =", p))
  
  ggplot(Topf18.COMBO.NS[Topf18.COMBO.NS$soil!="F",]) +
    geom_boxplot(aes(x = .data[[x]], y = .data[[y]]),
                 color="gray77", outlier.size = 0.1) +
    geom_jitter(aes(x = .data[[x]], y = .data[[y]],
                    color=soil, shape=acc), width = 0.1) +
    scale_color_manual(values = Kolor[2:4]) +
    scale_shape_manual(values = c(17, 19, 15, 20, 18, 0, 1, 2)) +
    scale_y_continuous(trans='log10') +
    scale_x_discrete(expand = c(0, 0)) +
    ggpubr::stat_compare_means(aes(x = .data[[x]], y = .data[[y]],
                              label = paste0("p = ", ..p.format..)),
                               label.x = 1.5, label.y = Inf, vjust=1,
                               size=4) +
    labs(tag="", title=, y=expression(""), x=expression("")) +
    theme_bw() +
    theme(panel.grid = element_blank()) +
    ggtitle(y)
}

TenFungi2PhenoPlotRS = map(response, ~boxplot_fun("reslevel", .x)) # "Map"-Loop aus dem purrr Package, die es erlaubt über alle Levels des Vektors "response" die Funktion "boxplot_fun" zu bedienen. "reslevel" ist hier hardcoded.

ggpubr::ggarrange(plotlist = TenFungi2PhenoPlotRS, common.legend = TRUE)


ggsave("TenFungiPlot_RS.tiff", units="cm", width=19, height=15, dpi=300, compression = 'lzw')


```




## Multiple regression: SDWRel & RRI explained by fungal quants. With sclaed qPCR data
# I always first, do a straight dirty linear model: then perform step() on that full model. Then I summ up the Final model.

# First, SDWRel.

```{r multreg 4 soils scaled, echo=FALSE}

# state the Model: SDWrel vs all ten fungi
multmod4soils <- lm(s.dw.ratioSNS ~
                 scale(Apha) + scale(AMF) + scale(Cros) + scale(Fave) + scale(Foxy) + scale(Fredo) + scale(Fsol) + scale(Rsol) + scale(Pult) + scale(Phoma),
                        data = Topf18.COMBO.NS)

summary(multmod4soils)
anova(multmod4soils)

par(mfrow=c(2,2))
plot(multmod4soils)  # get modeldiagnostic



# do some stepwise regression
car::vif(multmod4soils)   # get Variance Inflation Factors to see if I have multicolinearity

step(multmod4soils)

multmod4soilsFinal <- lm(s.dw.ratioSNS ~ scale(Apha) + scale(AMF) + scale(Fave) + scale(Fsol) + scale(Pult), data = Topf18.COMBO.NS) #state the final model from the stepwise regression
anova(multmod4soilsFinal)
summary(multmod4soilsFinal)

#par(mfrow=c(2,2))
#plot(multmod4soilsFinal)  # get modeldiagnostic

anova(multmod4soilsFinal)[1,2]/sum(anova(multmod4soilsFinal)[,2])   # partial r2 for Apha
anova(multmod4soilsFinal)[2,2]/sum(anova(multmod4soilsFinal)[,2])   # partial r2 for Apha
anova(multmod4soilsFinal)[3,2]/sum(anova(multmod4soilsFinal)[,2])   # partial r2 for Fave
anova(multmod4soilsFinal)[4,2]/sum(anova(multmod4soilsFinal)[,2])   # partial r2 for Fsol
anova(multmod4soilsFinal)[5,2]/sum(anova(multmod4soilsFinal)[,2])   # partial r2 for Pult

```

The full model has a adj. R2 of 0.28 (p<0.001). Apha, AMF, Fave are signif (<.05). VIFs are ok.
After step final model has Apha, AMF, Fave, Fsol, Pult in. Interestingly, Pult with a positive coefficient. Apha eplains 17%. Adj. R2 of final model 30%  ---> anyway this model over 4 soils does not really interest me!


the 3 sick soils only:

```{r multreg 3 sick soils scaled}
# SDWRel vs ten fungi oin 3 sick soils only
multmod3sick <- lm(s.dw.ratioSNS ~
                 scale(Apha) + scale(AMF) + scale(Cros) + scale(Fave) + scale(Foxy) + scale(Fredo) + scale(Fsol) + scale(Rsol) + scale(Pult) + scale(Phoma),
                        data = Topf18.COMBO.NS[Topf18.COMBO.NS$soil!= "F",])

summary(multmod3sick)
anova(multmod3sick)

#par(mfrow=c(2,2))
#plot(multmod3sick)  # get modeldiagnostic

# do some stepwise regression
car::vif(multmod3sick)   # get Variance Inflation Factors to see if I have multicolinearity

step(multmod3sick, trace = FALSE)

multmod3sickFinal <- lm(s.dw.ratioSNS ~ scale(Rsol) + scale(Foxy) + scale(Fsol) + scale(Cros) + scale(Fredo) + scale(AMF),
                        data = Topf18.COMBO.NS[Topf18.COMBO.NS$soil!= "F",]) #state the final model from the stepwise regression

anova(multmod3sickFinal)
summary(multmod3sickFinal)
SDWmultmod3sickFinal_Coeffs <- summary(multmod3sickFinal)$coefficients   # I save the coeffs of the variables that are in the final model, at the end, at W soil, I will store everytning in a list, that I can use for a nice model summary plot.

anova(multmod3sickFinal)[1,2]/sum(anova(multmod3sickFinal)[,2])   # partial r2 for Rsol
anova(multmod3sickFinal)[2,2]/sum(anova(multmod3sickFinal)[,2])   # partial r2 for Foxy
anova(multmod3sickFinal)[3,2]/sum(anova(multmod3sickFinal)[,2])   # partial r2 for Fsol
anova(multmod3sickFinal)[4,2]/sum(anova(multmod3sickFinal)[,2])   # partial r2 for Cros
anova(multmod3sickFinal)[5,2]/sum(anova(multmod3sickFinal)[,2])   # partial r2 for Fredo
anova(multmod3sickFinal)[6,2]/sum(anova(multmod3sickFinal)[,2])   # partial r2 for AMF

```

Full model: residuals ok. VIFs ok. Adj. R2=0.35; Apha, AMF & Fsol again significant (Fredo, Fave at <.1).
Step results in a model with Foxy, Rsol, Cros (pos. cooeff), Fredo (pos. coeff. !!), Fsol, AMF. This final model has an R2/adj. of 0.37/0.32; and only Fsol, Fredo & AMF are significant... explaining 15, 10 & 12% of variance respectively.
<br>

And as usual, within the 3 sick soils individaully:

```{r dataframe for partial r2 of the 3 final models}

# I prep a DF that will store the partial R2 from the final models (RRI & SDWrel.) after variable selection....

mmm <- matrix(nrow=10, ncol=7)
mmm <-as.data.frame(mmm)
colnames(mmm) <- c("Fungus", "r2RRI.H", "r2RRI.L", "r2RRI.W", "r2SDW.H", "r2SDW.L", "r2SDW.W")
mmm[,1] <- as.factor(c("AMF", "Apha", "Cros", "Fave", "Foxy", "Fredo", "Fsol", "Phoma", "Pult", "Rsol"))

```


```{r multreg H scaled}
# SDWRel vs ten fungi oin 3 sick soils only
multmodH <- lm(s.dw.ratioSNS ~
                 scale(Apha) + scale(AMF) + scale(Cros) + scale(Fave) + scale(Foxy)       + scale(Fsol) + scale(Rsol) + scale(Pult) + scale(Phoma),
                        data = Topf18.COMBO.NS[Topf18.COMBO.NS$soil== "H",])  # I manually exclude Fredo, cause it is 0 and wants to end up in the final model
summary(multmodH)

anova(multmodH)

#par(mfrow=c(2,2))
#plot(multmodH)  # get modeldiagnostic

# do some stepwise regression
car::vif(multmodH)   # get Variance Inflation Factors to see if I have multicolinearity

step(multmodH, trace=FALSE)

multmodHFinal <- lm(s.dw.ratioSNS ~ scale(AMF) + scale(Cros) + scale(Fsol) ,
                    data = Topf18.COMBO.NS[Topf18.COMBO.NS$soil== "H",]) #state the final model from the stepwise regression

car::vif(multmodHFinal)

anova(multmodHFinal)
summary(multmodHFinal)
SDWmultmodHFinal_Coeffs <- summary(multmodHFinal)$coefficients

mmm[mmm$Fungus=="AMF",]$r2SDW.H <- anova(multmodHFinal)[1,2]/sum(anova(multmodHFinal)[,2])   # partial r2 for AMF
mmm[mmm$Fungus=="Cros",]$r2SDW.H <- anova(multmodHFinal)[2,2]/sum(anova(multmodHFinal)[,2])   # partial r2 for Cros
mmm[mmm$Fungus=="Fsol",]$r2SDW.H <- anova(multmodHFinal)[3,2]/sum(anova(multmodHFinal)[,2])   # partial r2 for Fsol

```

Full model without Fredo (weil =0) und Adj. R2 = 0.16, not significant. Residuals ok. VIF ok, but Foxy = 12 and Phoma=8!
Step results in a model with AMF, Cros, Fsol; with AMF + Fsol significant. The two explain 20 & 15% variance, respectively. The overall adjR2 is 29%.

<br>


```{r multreg L scaled}
# SDWRel vs ten fungi oin 3 sick soils only
multmodL <- lm(s.dw.ratioSNS ~
                 scale(Apha) + scale(AMF) + scale(Cros) + scale(Fave) + scale(Foxy) + scale(Fredo) + scale(Fsol) + scale(Rsol) + scale(Pult) + scale(Phoma),
                        data = Topf18.COMBO.NS[Topf18.COMBO.NS$soil== "L",])
summary(multmodL)

anova(multmodL)

#par(mfrow=c(2,2))
#plot(multmodL)  # get modeldiagnostic

# do some stepwise regression
car::vif(multmodL)   # get Variance Inflation Factors to see if I have multicolinearity

step(multmodL, trace=FALSE)

multmodLFinal <- lm(s.dw.ratioSNS ~ scale(AMF) + scale(Foxy), data = Topf18.COMBO.NS[Topf18.COMBO.NS$soil== "L",]) #state the final model from the stepwise regression
anova(multmodLFinal)
summary(multmodLFinal)
SDWmultmodLFinal_Coeffs <- summary(multmodLFinal)$coefficients

mmm[mmm$Fungus=="AMF",]$r2SDW.L <- anova(multmodLFinal)[1,2]/sum(anova(multmodLFinal)[,2])   # R2 for AMF
mmm[mmm$Fungus=="Foxy",]$r2SDW.L <- anova(multmodLFinal)[2,2]/sum(anova(multmodLFinal)[,2])   # R2 for Foxy

```

Adj. R2 = 0.28,  non-significant (p=0.07). Residuals ok. VIF of Cros & Fave >5, Fsol = 9 !
The final model after the stepwise regression is composed of AMF & Foxy, with AMF significant. The model explains adjR2 40% variance. AMF explians 37%, Fox 7%.
<br>




```{r multreg W scaled}
# SDWRel vs ten fungi in 3 sick soils only
multmodW <- lm(s.dw.ratioSNS ~
                 scale(Apha) + scale(AMF) + scale(Cros) + scale(Fave) + scale(Foxy) + scale(Fredo) + scale(Fsol) + scale(Rsol) + scale(Pult) + scale(Phoma),
                        data = Topf18.COMBO.NS[Topf18.COMBO.NS$soil== "W",])
summary(multmodW)
anova(multmodW)

#par(mfrow=c(2,2))
#plot(multmodW)  # get modeldiagnostic

# do some stepwise regression
car::vif(multmodW)   # get Variance Inflation Factors to see if I have multicolinearity

step(multmodW, trace=FALSE)

multmodWFinal <- lm(s.dw.ratioSNS ~ scale(AMF) + scale(Apha) + scale(Fredo) + scale(Rsol), data = Topf18.COMBO.NS[Topf18.COMBO.NS$soil== "W",]) #state the final model from the stepwise regression
anova(multmodWFinal)
summary(multmodWFinal)
SDWmultmodWFinal_Coeffs <- summary(multmodWFinal)$coefficients

mmm[mmm$Fungus=="AMF",]$r2SDW.W <- anova(multmodWFinal)[1,2]/sum(anova(multmodWFinal)[,2])   # R2 for AMF
mmm[mmm$Fungus=="Apha",]$r2SDW.W <- anova(multmodWFinal)[2,2]/sum(anova(multmodWFinal)[,2])   # R2 for Apha
mmm[mmm$Fungus=="Fredo",]$r2SDW.W <- anova(multmodWFinal)[3,2]/sum(anova(multmodWFinal)[,2])   # R2 for Fredo
mmm[mmm$Fungus=="Rsol",]$r2SDW.W <- anova(multmodWFinal)[4,2]/sum(anova(multmodWFinal)[,2])   # R2 for Rsol


```
Adj R2 = 0.6...Model not significant! No fungus significant. Residuals ok. VIF of Fredo = 6.3... 
After the step, only Apha, AMF, Rsol & Fredo are left in the model. This overall model is not significant (p 0.05); R2=0.2.  Only AMF is significant. Apha explains 15%.



```{r SDW save coeffs from 3,H,L,W}
# Save the coefficients of the models in a list

SDWmultregCoeffs <- list(SDWmultmod3sickFinal_Coeffs, SDWmultmodHFinal_Coeffs, SDWmultmodLFinal_Coeffs, SDWmultmodWFinal_Coeffs)
names(SDWmultregCoeffs) <- c("3sick", "H", "L", "W")

saveRDS(SDWmultregCoeffs, "SDWmultregCoeffs_Liste.rds")

```




## Second, RRI

I do not do 4 soils but start with the 3 sick soils only:

```{r RRI multreg 3 sick soils scaled}
# RRI vs ten fungi oin 3 sick soils only
RRImultmod3sick <- lm(r.aspectMEDIAN ~
                 scale(Apha) + scale(AMF) + scale(Cros) + scale(Fave) + scale(Foxy) + scale(Fredo) +                                       scale(Fsol) + scale(Rsol) + scale(Pult) + scale(Phoma),
                        data = Topf18.COMBO.NS[Topf18.COMBO.NS$soil!= "F",])

summary(RRImultmod3sick)
anova(RRImultmod3sick)

#par(mfrow=c(2,2))
plot(RRImultmod3sick)  # get modeldiagnostic

# do some stepwise regression
car::vif(RRImultmod3sick)   # get Variance Inflation Factors to see if I have multicolinearity


intermediateModel <- lm(r.aspectMEDIAN~., data=RRImultmod3sick$model)   # this is a trick to avoid problems with NAs and a step() error
step(intermediateModel, trace = FALSE)

RRImultmod3sickFinal <- lm(r.aspectMEDIAN ~ scale(Apha) + scale(Fave) + scale(Fsol),
                        data = Topf18.COMBO.NS[Topf18.COMBO.NS$soil!= "F",]) #state the final model from the stepwise regression

anova(RRImultmod3sickFinal)
summary(RRImultmod3sickFinal)
plot(RRImultmod3sickFinal)
RRImultmod3sickFinal_Coeffs <- summary(RRImultmod3sickFinal)$coefficients   # I save the coeffs of the variables that are in the final model, at the end, at W soil, I will store everytning in a list, that I can use for a nice model summary plot.

anova(RRImultmod3sickFinal)[1,2]/sum(anova(RRImultmod3sickFinal)[,2])   # R2 for Apha
anova(RRImultmod3sickFinal)[2,2]/sum(anova(RRImultmod3sickFinal)[,2])   # R2 for Fave
anova(RRImultmod3sickFinal)[3,2]/sum(anova(RRImultmod3sickFinal)[,2])   # R2 for Fsol

```

Full model: residuals are not ok! VIFs ok. Adj. R2=0.34; Apha, AMF, Cros, Fave & Fsol  significant.
Step results in a model with Apha, Fave and Fsol. Residuals of this final model are not ok. This final model has an adj R2 of 0.46.
<br>

And as usual, within the 3 sick soils individaully:

```{r RRI multreg H scaled}

# RRI vs ten fungi in H soil

RRImultmodH <- lm(r.aspectMEDIAN ~
                 scale(Apha) + scale(AMF) + scale(Cros) + scale(Fave) + scale(Foxy)       + scale(Fsol) + scale(Rsol) + scale(Pult) + scale(Phoma),
                        data = Topf18.COMBO.NS[Topf18.COMBO.NS$soil== "H",])  # I manually exclude Fredo, cause it is 0 and wants to end up in the final model
summary(RRImultmodH)

anova(RRImultmodH)

#par(mfrow=c(2,2))
#plot(RRImultmodH)  # get modeldiagnostic

# do some stepwise regression
car::vif(RRImultmodH)   # get Variance Inflation Factors to see if I have multicolinearity

step(RRImultmodH, trace=FALSE)

RRImultmodHFinal <- lm(r.aspectMEDIAN ~ scale(AMF) + scale(Foxy) + scale(Pult),
                    data = Topf18.COMBO.NS[Topf18.COMBO.NS$soil== "H",]) # state the final model from the stepwise regression

car::vif(RRImultmodHFinal)

anova(RRImultmodHFinal)
summary(RRImultmodHFinal)
RRImultmodHFinal_Coeffs <- summary(RRImultmodHFinal)$coefficients

plot(RRImultmodHFinal)


mmm[mmm$Fungus=="AMF",]$r2RRI.H <- anova(RRImultmodHFinal)[1,2]/sum(anova(RRImultmodHFinal)[,2])   # r2 for AMF
mmm[mmm$Fungus=="Foxy",]$r2RRI.H <- anova(RRImultmodHFinal)[2,2]/sum(anova(RRImultmodHFinal)[,2])   # r2 for Foxy
mmm[mmm$Fungus=="Pult",]$r2RRI.H <- anova(RRImultmodHFinal)[3,2]/sum(anova(RRImultmodHFinal)[,2])   # r2 for Pult

```

Full model without Fredo (weil =0) und Adj. R2 = 0.50. Only AMF & Foxy significant. Residuals not ok. VIF ok, except Foxy = 11 (as with SDWrel.) !!!
Step results in a model with AMF, Foxy, Pult; with Foxy & Fsol only significant. The overall adjR2 is 55%.

<br>


```{r RRI multreg L scaled}

# RRI vs ten fungi in L

RRImultmodL <- lm(r.aspectMEDIAN ~
                 scale(Apha) + scale(AMF) + scale(Cros) + scale(Fave) + scale(Foxy) + scale(Fredo) + scale(Fsol) + scale(Rsol) + scale(Pult) + scale(Phoma),
                        data = Topf18.COMBO.NS[Topf18.COMBO.NS$soil== "L",])
summary(RRImultmodL)

anova(RRImultmodL)

#par(mfrow=c(2,2))
#plot(RRImultmodL)  # get modeldiagnostic

# do some stepwise regression
car::vif(RRImultmodL)   # get Variance Inflation Factors to see if I have multicolinearity

step(RRImultmodL, trace=FALSE)

RRImultmodLFinal <- lm(r.aspectMEDIAN ~ scale(AMF) + scale(Cros) + scale(Rsol) , data = Topf18.COMBO.NS[Topf18.COMBO.NS$soil== "L",]) #state the final model from the stepwise regression
anova(RRImultmodLFinal)
summary(RRImultmodLFinal)
RRImultmodLFinal_Coeffs <- summary(RRImultmodLFinal)$coefficients

#plot(RRImultmodLFinal)

mmm[mmm$Fungus=="AMF",]$r2RRI.L <- anova(RRImultmodLFinal)[1,2]/sum(anova(RRImultmodLFinal)[,2])   # r2 for AMF
mmm[mmm$Fungus=="Cros",]$r2RRI.L <- anova(RRImultmodLFinal)[2,2]/sum(anova(RRImultmodLFinal)[,2])   # r2 for Cros
mmm[mmm$Fungus=="Rsol",]$r2RRI.L <- anova(RRImultmodLFinal)[3,2]/sum(anova(RRImultmodLFinal)[,2])   # r2 for Rsol


```

Adj. R2 = 0.49,  significant (p=0.005).  AMF, Fave, Cros significant. Residuals ok. VIFs ok.
The final model after the stepwise regression is composed of AMF, Cros & Rsol significant. The model explains 57% variance.
<br>

```{r RRI multreg W scaled}

# RRI vs ten fungi in W

RRImultmodW <- lm(r.aspectMEDIAN ~
                 scale(Apha) + scale(AMF) + scale(Cros) + scale(Fave) + scale(Foxy) + scale(Fredo) + scale(Fsol) + scale(Rsol) + scale(Pult) + scale(Phoma),
                        data = Topf18.COMBO.NS[Topf18.COMBO.NS$soil== "W",])
summary(RRImultmodW)
anova(RRImultmodW)

#par(mfrow=c(2,2))
#plot(RRImultmodW)  # get modeldiagnostic

# do some stepwise regression
car::vif(RRImultmodW)   # get Variance Inflation Factors to see if I have multicolinearity

step(RRImultmodW, trace=FALSE)

RRImultmodWFinal <- lm(r.aspectMEDIAN ~ scale(Apha) + scale(Fredo) + scale(Fsol) + scale(Rsol), data = Topf18.COMBO.NS[Topf18.COMBO.NS$soil== "W",]) #state the final model from the stepwise regression
anova(RRImultmodWFinal)
summary(RRImultmodWFinal)
RRImultmodWFinal_Coeffs <- summary(RRImultmodWFinal)$coefficients


plot(RRImultmodWFinal)

#get the adj. r2 of the model an calculate effecte size (Cohens f)
adjR2 <- summary(RRImultmodWFinal)$adj.r.squared
cohF <- sqrt(adjR2/(1-adjR2))



# get the partial r2 of the factors
mmm[mmm$Fungus=="Apha",]$r2RRI.W <- anova(RRImultmodWFinal)[1,2]/sum(anova(RRImultmodWFinal)[,2])   # r2 for Apha
mmm[mmm$Fungus=="Fredo",]$r2RRI.W <- anova(RRImultmodWFinal)[2,2]/sum(anova(RRImultmodWFinal)[,2])   # r2 for Fredo
mmm[mmm$Fungus=="Fsol",]$r2RRI.W <- anova(RRImultmodWFinal)[3,2]/sum(anova(RRImultmodWFinal)[,2])   # r2 for Fsol
mmm[mmm$Fungus=="Rsol",]$r2RRI.W <- anova(RRImultmodWFinal)[4,2]/sum(anova(RRImultmodWFinal)[,2])   # r2 for Rsol


# final prep of the dataframe that contains the partial r2

mmm[,2:7] <- round(mmm[,2:7],2)
multregSTEPfinal_RRISDW_partialR2s <- mmm
#write.csv(multregSTEPfinal_RRISDW_partialR2s, file="multregSTEPfinal_RRISDW_partialR2s.csv")

multregSTEPfinal_RRISDW_partialR2s <- melt(mmm)



```

full model is not significant and has R2 =.35.
Final model after step has Fsol, Rsol, Fredo, & Apha. Both not significant in ANOVA.. Final model explains 46%.

```{r RRI save coeffs from 3,H,L,W}
# Save the coefficients of the models in a list

RRImultregCoeffs <- list(RRImultmod3sickFinal_Coeffs, RRImultmodHFinal_Coeffs, RRImultmodLFinal_Coeffs ,RRImultmodWFinal_Coeffs)
names(RRImultregCoeffs) <- c("3sick", "H", "L", "W")
#saveRDS(RRImultregCoeffs, "RRImultregCoeffs_Liste.rds")
```



### Multreg Step Analysis WITHOUT AMF

the 3 sick soils only:

```{r multreg noAMF 3 sick soils scaled}
# SDWRel vs ten fungi oin 3 sick soils only
noAMF3sick <- lm(s.dw.ratioSNS ~
                     scale(Apha) + scale(Cros) + scale(Fave) + scale(Foxy) + scale(Fredo) + scale(Fsol) + scale(Rsol) + scale(Pult) + scale(Phoma),
                   data = Topf18.COMBO.NS[Topf18.COMBO.NS$soil!= "F",])

summary(noAMF3sick)
anova(noAMF3sick)

# do some stepwise regression
car::vif(noAMF3sick)   # get Variance Inflation Factors to see if I have multicolinearity

step(noAMF3sick, trace = FALSE)

noAMF3sickFinal <- lm(s.dw.ratioSNS ~ scale(Rsol) + scale(Fsol) + scale(Cros) + scale(Fredo),
                        data = Topf18.COMBO.NS[Topf18.COMBO.NS$soil!= "F",]) #state the final model from the stepwise regression

anova(noAMF3sickFinal)
summary(noAMF3sickFinal)
SDWmultmodnoAMF3sickFinal_Coeffs <- summary(noAMF3sickFinal)$coefficients   # I save the coeffs of the variables that are in the final model, at the end, at W soil, I will store everytning in a list, that I can use for a nice model summary plot.

anova(noAMF3sickFinal)[1,2]/sum(anova(multmod3sickFinal)[,2])   # partial r2 for Rsol
anova(noAMF3sickFinal)[2,2]/sum(anova(multmod3sickFinal)[,2])   # partial r2 for Fsol
anova(noAMF3sickFinal)[3,2]/sum(anova(multmod3sickFinal)[,2])   # partial r2 for Cros
anova(noAMF3sickFinal)[4,2]/sum(anova(multmod3sickFinal)[,2])   # partial r2 for Fredo


```

Full model: residuals not ok. VIFs ok. Adj. R2=0.23; Apha, Fave, Fredo & Fsol sign.
Step results in a model with  Rsol, Cros (pos. cooeff), Fredo (pos. coeff. !!), Fsol. This final model has an R2/adj. of 0.30/0.26; and only Fsol & Fredo are significant... explaining 18 & 10% of variance respectively.
<br>
  
  
#And as usual, within the 3 sick soils individaully:
  
```{r noAMF dataframe for partial r2 of the 3 final models}

# I prep a DF that will store the partial R2 from the final models (RRI & SDWrel.) after variable selection....

mmmNOAMF <- matrix(nrow=10, ncol=7)
mmmNOAMF <-as.data.frame(mmmNOAMF)
colnames(mmmNOAMF) <- c("Fungus", "r2RRI.H", "r2RRI.L", "r2RRI.W", "r2SDW.H", "r2SDW.L", "r2SDW.W")
mmmNOAMF[,1] <- as.factor(c("AMF", "Apha", "Cros", "Fave", "Foxy", "Fredo", "Fsol", "Phoma", "Pult", "Rsol"))

```


```{r noAMF multreg H scaled}
# SDWRel vs ten fungi oin 3 sick soils only
noAMFmultmodH <- lm(s.dw.ratioSNS ~
                 scale(Apha) + scale(Cros) + scale(Fave) + scale(Foxy)       + scale(Fsol) + scale(Rsol) + scale(Pult) + scale(Phoma), data = Topf18.COMBO.NS[Topf18.COMBO.NS$soil== "H",])  # I manually exclude Fredo, cause it is 0 and wants to end up in the final model
summary(noAMFmultmodH)
anova(noAMFmultmodH)

# do some stepwise regression
car::vif(noAMFmultmodH)   # get Variance Inflation Factors to see if I have multicolinearity

step(noAMFmultmodH, trace=FALSE)

noAMFmultmodHFinal <- lm(s.dw.ratioSNS ~ scale(Cros) + scale(Fsol) ,
                    data = Topf18.COMBO.NS[Topf18.COMBO.NS$soil== "H",]) #state the final model from the stepwise regression

car::vif(noAMFmultmodHFinal)

anova(noAMFmultmodHFinal)
summary(noAMFmultmodHFinal)
plot(noAMFmultmodHFinal)

mmmNOAMF[mmmNOAMF$Fungus=="Cros",]$r2SDW.H <- round(anova(noAMFmultmodHFinal)[1,2]/sum(anova(noAMFmultmodHFinal)[,2]),2)   # partial r2 for Cros
mmmNOAMF[mmmNOAMF$Fungus=="Fsol",]$r2SDW.H <- round(anova(noAMFmultmodHFinal)[2,2]/sum(anova(noAMFmultmodHFinal)[,2]),2)   # partial r2 for Fsol

```

Full model without Fredo (weil =0) und Adj. R2 = 0.16, not significant. VIF ok, but Foxy = 12 and Phoma=8!
Step results in a model with Cros & Fsol; Fsol significant, explaining 28%. The overall adjR2 is 26%. Residual QQplot not really ok.

<br>
  
  
```{r noAMF multreg L scaled}
# SDWRel vs ten fungi oin 3 sick soils only
noAMFmultmodL <- lm(s.dw.ratioSNS ~
                 scale(Apha) + scale(Cros) + scale(Fave) + scale(Foxy) + scale(Fredo) + scale(Fsol) + scale(Rsol) + scale(Pult) + scale(Phoma),
               data = Topf18.COMBO.NS[Topf18.COMBO.NS$soil== "L",])
summary(noAMFmultmodL)
anova(noAMFmultmodL)

# do some stepwise regression
car::vif(noAMFmultmodL)   # get Variance Inflation Factors to see if I have multicolinearity
step(noAMFmultmodL, trace=FALSE)

noAMFmultmodLFinal <- lm(s.dw.ratioSNS ~ scale(Foxy) + scale(Fredo) + scale(Fsol) + scale(Pult), data = Topf18.COMBO.NS[Topf18.COMBO.NS$soil== "L",]) #state the final model from the stepwise regression
anova(noAMFmultmodLFinal)
summary(noAMFmultmodLFinal)
#plot(noAMFmultmodLFinal)

mmmNOAMF[mmmNOAMF$Fungus=="Foxy",]$r2SDW.L <- round(anova(noAMFmultmodLFinal)[1,2]/sum(anova(noAMFmultmodLFinal)[,2]),2)   # R2 for Foxy
mmmNOAMF[mmmNOAMF$Fungus=="Fredo",]$r2SDW.L <- round(anova(noAMFmultmodLFinal)[2,2]/sum(anova(noAMFmultmodLFinal)[,2]),2)   # R2 for Fredo
mmmNOAMF[mmmNOAMF$Fungus=="Fsol",]$r2SDW.L <- round(anova(noAMFmultmodLFinal)[3,2]/sum(anova(noAMFmultmodLFinal)[,2]),2)   # R2 for Fsol
mmmNOAMF[mmmNOAMF$Fungus=="Pult",]$r2SDW.L <- round(anova(noAMFmultmodLFinal)[4,2]/sum(anova(noAMFmultmodLFinal)[,2]),2)   # R2 for Pult
```

Adj. R2 = 0.17,  non-significant (p=0.15). VIF of Cros & Fave >4, Fsol = 5 !
The final model after the stepwise regression is composed of Foxy, Fredo, Fsol, Pult with Fox/Fsol signif.. Residuals ok.
The model explains adjR2 27% variance. Fox 12%, Fredo 1, Fsol 17, Pult 6%.
<br>
  
  
```{r noAMF multreg W scaled}

# SDWRel vs ten fungi in 3 sick soils only
noAMFmultmodW <- lm(s.dw.ratioSNS ~
                 scale(Apha)+ scale(Cros) + scale(Fave) + scale(Foxy) + scale(Fredo) + scale(Fsol) + scale(Rsol) + scale(Pult) + scale(Phoma),
               data = Topf18.COMBO.NS[Topf18.COMBO.NS$soil== "W",])
summary(noAMFmultmodW)
anova(noAMFmultmodW)

# do some stepwise regression
car::vif(noAMFmultmodW)   # get Variance Inflation Factors to see if I have multicolinearity

step(noAMFmultmodW, trace=FALSE)

noAMFmultmodWFinal <- lm(s.dw.ratioSNS ~ scale(Apha) + scale(Fsol), data = Topf18.COMBO.NS[Topf18.COMBO.NS$soil== "W",]) #state the final model from the stepwise regression
anova(noAMFmultmodWFinal)
summary(noAMFmultmodWFinal)
#plot(noAMFmultmodWFinal)

mmmNOAMF[mmmNOAMF$Fungus=="Apha",]$r2SDW.W <- round(anova(multmodWFinal)[1,2]/sum(anova(multmodWFinal)[,2]),2)   # R2 for AMF
mmmNOAMF[mmmNOAMF$Fungus=="Fsol",]$r2SDW.W <- round(anova(multmodWFinal)[2,2]/sum(anova(multmodWFinal)[,2]),2)   # R2 for Fsol

```
Adj R2 = -0.00...Model not significant! No fungus significant. VIF of Fredo = 5.3... 
After the step, only Apha & Fsol (positive coeff.!) are left in the model. This overall model is not significant (p=0.06); R2=0.13. Resiualds good.
Only Apha is significant. Apha explains 15%, Fsol 5%.

### Compare Stepwise reduced models with and without AMF
```{r Compare multreg with/out AMF}

mmm
mmmNOAMF

```





